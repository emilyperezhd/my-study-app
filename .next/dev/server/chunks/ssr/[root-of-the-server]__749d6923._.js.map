{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 10, "column": 0}, "map": {"version":3,"sources":["file:///Users/emilyperez/Study%20App/my-study-app/src/lib/db.ts"],"sourcesContent":["import { PrismaClient } from \"@prisma/client\";\n\n// This weird code prevents the \"Too many connections\" error\nconst globalForPrisma = global as unknown as { prisma: PrismaClient };\n\nexport const db = globalForPrisma.prisma || new PrismaClient();\n\nif (process.env.NODE_ENV !== \"production\") globalForPrisma.prisma = db;"],"names":[],"mappings":";;;;AAAA;;AAEA,4DAA4D;AAC5D,MAAM;AAEC,MAAM,KAAK,gBAAgB,MAAM,IAAI,IAAI,6IAAY;AAE5D,wCAA2C,gBAAgB,MAAM,GAAG"}},
    {"offset": {"line": 72, "column": 0}, "map": {"version":3,"sources":["file:///Users/emilyperez/Study%20App/my-study-app/src/app/actions.ts"],"sourcesContent":["'use server'\n\nimport { db } from \"../lib/db\";\nimport { revalidatePath } from \"next/cache\";\nimport { ChatOpenAI } from \"@langchain/openai\";\nimport { PromptTemplate } from \"@langchain/core/prompts\";\n\n// @ts-ignore\nimport PDFParser from \"pdf2json\";\n\n// --- 1. UPLOAD ACTION ---\nexport async function uploadPdf(formData: FormData) {\n  try {\n    const file = formData.get(\"file\") as File;\n    if (!file) throw new Error(\"No file found\");\n\n    const arrayBuffer = await file.arrayBuffer();\n    const buffer = Buffer.from(arrayBuffer);\n\n    const text = await new Promise<string>((resolve, reject) => {\n        const parser = new PDFParser(null, 1);\n\n        parser.on(\"pdfParser_dataError\", (errData: any) => {\n            console.error(\"PDF Parser Error:\", errData.parserError);\n            resolve(\"\"); \n        });\n\n        parser.on(\"pdfParser_dataReady\", (pdfData: any) => {\n            try {\n                if (!pdfData || !pdfData.formImage || !pdfData.formImage.Pages) {\n                    resolve(\"\");\n                    return;\n                }\n                let extractedText = \"\";\n                // @ts-ignore\n                pdfData.formImage.Pages.forEach((page) => {\n                     // @ts-ignore\n                    if (page.Texts) {\n                         // @ts-ignore\n                        page.Texts.forEach((textItem) => {\n                             // @ts-ignore\n                            if (textItem.R) {\n                                // @ts-ignore\n                                textItem.R.forEach((run) => {\n                                    if (run.T) extractedText += decodeURIComponent(run.T) + \" \";\n                                });\n                            }\n                        });\n                    }\n                    extractedText += \"\\n\";\n                });\n                resolve(extractedText);\n            } catch (error) {\n                console.error(\"Manual extraction failed:\", error);\n                resolve(\"\"); \n            }\n        });\n\n        try {\n            parser.parseBuffer(buffer);\n        } catch (e) {\n            console.error(\"Buffer error:\", e);\n            resolve(\"\");\n        }\n    });\n\n    const finalContent = typeof text === 'string' && text.trim().length > 0 \n        ? text \n        : \"⚠️ Text could not be extracted.\";\n\n    await db.course.create({\n      data: {\n        title: file.name,\n        content: finalContent,\n      }\n    });\n\n    revalidatePath(\"/\");\n  } catch (error) {\n    console.error(\"Upload Error:\", error);\n  }\n}\n\n// --- 2. MANAGEMENT ACTIONS ---\n\nexport async function deleteCourse(id: string) {\n  try {\n    await db.course.delete({ where: { id: id } });\n    revalidatePath(\"/\");\n  } catch (error) {\n    console.error(\"Delete Error:\", error);\n  }\n}\n\nexport async function renameCourse(id: string, newTitle: string) {\n  try {\n    await db.course.update({ where: { id: id }, data: { title: newTitle } });\n    revalidatePath(\"/\");\n  } catch (error) {\n    console.error(\"Rename Error:\", error);\n  }\n}\n\n// --- 3. GENERATORS ---\n\nexport async function generateStudyGuide(id: string) {\n  try {\n    const note = await db.course.findUnique({ where: { id: id } });\n    if (!note || !note.content) throw new Error(\"Note not found\");\n\n    const model = new ChatOpenAI({ \n      modelName: \"gpt-4o-mini\", \n      openAIApiKey: process.env.OPENAI_API_KEY \n    });\n\n    const prompt = PromptTemplate.fromTemplate(\n      `You are a strict academic tutor. Create a structured study guide.\n       Rules: HTML format only, use <h1>, <h2>, <ul>, <strong>. No Markdown.\n       Text: {text}`\n    );\n\n    const chain = prompt.pipe(model);\n    const response = await chain.invoke({ text: note.content.slice(0, 25000) });\n\n    await db.course.update({\n      where: { id: id },\n      data: { summary: response.content as string }\n    });\n\n    revalidatePath(`/notes/${id}`);\n  } catch (error) {\n    console.error(\"AI Study Guide Error:\", error);\n  }\n}\n\nexport async function generateQuiz(id: string) {\n  try {\n    const note = await db.course.findUnique({ where: { id: id } });\n    if (!note || !note.content) throw new Error(\"Note not found\");\n\n    const model = new ChatOpenAI({\n      modelName: \"gpt-4o-mini\",\n      openAIApiKey: process.env.OPENAI_API_KEY,\n      temperature: 0.1, \n      modelKwargs: { response_format: { type: \"json_object\" } } \n    });\n\n    const prompt = PromptTemplate.fromTemplate(\n      `Generate 5 difficult multiple-choice questions based on the provided text.\n       Return JSON object: {{ \"questions\": [ {{ \"question\": \"...\", \"options\": [\"...\"], \"answer\": \"...\" }} ] }}\n       Text: {text}`\n    );\n\n    const chain = prompt.pipe(model);\n    const response = await chain.invoke({ text: note.content.slice(0, 25000) });\n    \n    const content = typeof response.content === 'string' ? response.content : JSON.stringify(response.content);\n    const data = JSON.parse(content);\n    \n    await db.question.createMany({\n      data: data.questions.map((q: any) => ({\n        courseId: id,\n        question: q.question,\n        options: q.options,\n        answer: q.answer\n      }))\n    });\n\n    revalidatePath(`/notes/${id}`);\n  } catch (error) {\n    console.error(\"AI Quiz Error:\", error);\n  }\n}\n\nexport async function generateFlashcards(id: string) {\n  try {\n    const note = await db.course.findUnique({ where: { id: id } });\n    if (!note || !note.content) throw new Error(\"Note not found\");\n\n    const model = new ChatOpenAI({\n      modelName: \"gpt-4o-mini\",\n      openAIApiKey: process.env.OPENAI_API_KEY,\n      temperature: 0.1, \n      modelKwargs: { response_format: { type: \"json_object\" } } \n    });\n\n    const prompt = PromptTemplate.fromTemplate(\n      `Generate 15 study flashcards based on the provided text.\n       Focus on key definitions, formulas, and concepts.\n       Return JSON object: {{ \"flashcards\": [ {{ \"front\": \"Term\", \"back\": \"Definition\" }} ] }}\n       Text: {text}`\n    );\n\n    const chain = prompt.pipe(model);\n    const response = await chain.invoke({ text: note.content.slice(0, 25000) });\n    \n    const content = typeof response.content === 'string' ? response.content : JSON.stringify(response.content);\n    const data = JSON.parse(content);\n    \n    await db.flashcard.createMany({\n      data: data.flashcards.map((f: any) => ({\n        courseId: id,\n        front: f.front,\n        back: f.back\n      }))\n    });\n\n    revalidatePath(`/notes/${id}`);\n  } catch (error) {\n    console.error(\"Flashcard Gen Error:\", error);\n  }\n}\n\nexport async function generatePracticeExam(id: string) {\n  try {\n    const note = await db.course.findUnique({ where: { id: id } });\n    if (!note || !note.content) throw new Error(\"Note not found\");\n\n    const model = new ChatOpenAI({\n      modelName: \"gpt-4o-mini\",\n      openAIApiKey: process.env.OPENAI_API_KEY,\n      temperature: 0.1, \n      modelKwargs: { response_format: { type: \"json_object\" } } \n    });\n\n    const prompt = PromptTemplate.fromTemplate(\n      `Generate a Practice Midterm Exam with 20 difficult multiple-choice questions based on the text.\n       Include an \"explanation\" field explaining the correct answer.\n       Return JSON object: \n       {{ \"questions\": [ {{ \"question\": \"...\", \"options\": [\"...\"], \"answer\": \"...\", \"explanation\": \"...\" }} ] }}\n       Text: {text}`\n    );\n\n    const chain = prompt.pipe(model);\n    const response = await chain.invoke({ text: note.content.slice(0, 30000) });\n    \n    const content = typeof response.content === 'string' ? response.content : JSON.stringify(response.content);\n    const data = JSON.parse(content);\n    \n    await db.examQuestion.createMany({\n      data: data.questions.map((q: any) => ({\n        courseId: id,\n        question: q.question,\n        options: q.options,\n        answer: q.answer,\n        explanation: q.explanation\n      }))\n    });\n\n    revalidatePath(`/notes/${id}`);\n  } catch (error) {\n    console.error(\"Exam Gen Error:\", error);\n  }\n}\n\n// --- SMART CROSSWORD GENERATOR ---\n// Uses a custom algorithm to build the grid instead of trusting the AI to draw it.\nexport async function generateCrossword(id: string) {\n  try {\n    const note = await db.course.findUnique({ where: { id: id } });\n    if (!note || !note.content) throw new Error(\"Note not found\");\n\n    const model = new ChatOpenAI({\n      modelName: \"gpt-4o\",\n      openAIApiKey: process.env.OPENAI_API_KEY,\n      temperature: 0.2, \n      modelKwargs: { response_format: { type: \"json_object\" } } \n    });\n\n    // 1. Get just the words and clues\n    const prompt = PromptTemplate.fromTemplate(\n      `Extract 20 glossary terms from the text for a crossword puzzle.\n       Rules:\n       - Single word answers only (no spaces/hyphens).\n       - Max 10 characters per word.\n       - Uppercase only.\n       \n       Return JSON:\n       {{\n         \"terms\": [\n           {{ \"word\": \"JAVA\", \"clue\": \"A programming language\" }}\n         ]\n       }}\n       \n       Text: {text}`\n    );\n\n    const chain = prompt.pipe(model);\n    const response = await chain.invoke({ text: note.content.slice(0, 30000) });\n    const content = typeof response.content === 'string' ? response.content : JSON.stringify(response.content);\n    const data = JSON.parse(content);\n    \n    const terms = data.terms;\n\n    // 2. Build the Grid Manually (Simple Layout Algorithm)\n    const gridSize = 12; // Slightly larger to fit more words\n    let grid = Array(gridSize).fill(null).map(() => Array(gridSize).fill(\"\"));\n    let placedWords = [] as any[];\n\n    // Sort by length (longest first)\n    terms.sort((a: any, b: any) => b.word.length - a.word.length);\n\n    // Place first word in center\n    const firstWord = terms[0];\n    if (firstWord) {\n        const startCol = Math.floor((gridSize - firstWord.word.length) / 2);\n        const startRow = Math.floor(gridSize / 2);\n        for (let i = 0; i < firstWord.word.length; i++) {\n            grid[startRow][startCol + i] = firstWord.word[i];\n        }\n        placedWords.push({ ...firstWord, row: startRow, col: startCol, dir: 'across' });\n    }\n\n    // Try to place other words\n    for (let i = 1; i < terms.length; i++) {\n        const currentTerm = terms[i];\n        const word = currentTerm.word;\n        let placed = false;\n\n        // Try to find an intersection\n        for (const placedWord of placedWords) {\n            if (placed) break;\n            \n            // Check every letter overlap\n            for (let j = 0; j < word.length; j++) {\n                if (placed) break;\n                for (let k = 0; k < placedWord.word.length; k++) {\n                    if (word[j] === placedWord.word[k]) {\n                        // Found a common letter!\n                        // If placed word is Across, we try Down. If Down, we try Across.\n                        const newDir = placedWord.dir === 'across' ? 'down' : 'across';\n                        \n                        // Calculate potential start pos\n                        let newRow = placedWord.row;\n                        let newCol = placedWord.col;\n                        \n                        if (placedWord.dir === 'across') {\n                            // Placed is horizontal at (row, col). Common char is at (row, col+k)\n                            // New word is Vertical. Common char is at index j.\n                            // So new word starts at (row - j, col + k)\n                            newRow = placedWord.row - j;\n                            newCol = placedWord.col + k;\n                        } else {\n                            // Placed is vertical at (row, col). Common char is at (row+k, col)\n                            // New word is Horizontal. Common char is at index j.\n                            // So new word starts at (row + k, col - j)\n                            newRow = placedWord.row + k;\n                            newCol = placedWord.col - j;\n                        }\n\n                        // Validate Bounds\n                        if (newRow < 0 || newCol < 0 || \n                            (newDir === 'across' && newCol + word.length > gridSize) ||\n                            (newDir === 'down' && newRow + word.length > gridSize)) {\n                            continue;\n                        }\n\n                        // Validate Collisions\n                        let collision = false;\n                        for (let c = 0; c < word.length; c++) {\n                            const r = newDir === 'across' ? newRow : newRow + c;\n                            const col = newDir === 'across' ? newCol + c : newCol;\n                            \n                            // Cell must be empty OR match exactly\n                            if (grid[r][col] !== \"\" && grid[r][col] !== word[c]) {\n                                collision = true;\n                                break;\n                            }\n                        }\n\n                        if (!collision) {\n                            // Place it!\n                            for (let c = 0; c < word.length; c++) {\n                                const r = newDir === 'across' ? newRow : newRow + c;\n                                const col = newDir === 'across' ? newCol + c : newCol;\n                                grid[r][col] = word[c];\n                            }\n                            placedWords.push({ ...currentTerm, row: newRow, col: newCol, dir: newDir });\n                            placed = true;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    // 3. Generate Final Output Structure\n    const numbers = Array(gridSize).fill(null).map(() => Array(gridSize).fill(0));\n    const clues = { across: [] as any[], down: [] as any[] };\n    let clueNum = 1;\n\n    // Sort placed words by position to number them correctly (reading order)\n    placedWords.sort((a, b) => (a.row - b.row) || (a.col - b.col));\n\n    placedWords.forEach((pw) => {\n        // Assign number if not exists\n        let num = numbers[pw.row][pw.col];\n        if (num === 0) {\n            num = clueNum++;\n            numbers[pw.row][pw.col] = num;\n        }\n        \n        if (pw.dir === 'across') {\n            clues.across.push({ number: num, clue: pw.clue });\n        } else {\n            clues.down.push({ number: num, clue: pw.clue });\n        }\n    });\n\n    const finalData = { grid, numbers, clues };\n    \n    await db.crossword.create({\n      data: { courseId: id, puzzle: finalData }\n    });\n\n    revalidatePath(`/notes/${id}`);\n  } catch (error) {\n    console.error(\"Crossword Gen Error:\", error);\n  }\n}\n\nexport async function saveQuizResult(courseId: string, score: number, total: number) {\n  try {\n    await db.quizResult.create({\n      data: { courseId, score, total },\n    });\n    revalidatePath(`/notes/${courseId}`);\n  } catch (error) {\n    console.error(\"Save Error:\", error);\n  }\n}\n\nexport async function saveExamResult(courseId: string, score: number, total: number) {\n  try {\n    await db.examResult.create({\n      data: { courseId, score, total },\n    });\n    revalidatePath(`/notes/${courseId}`);\n  } catch (error) {\n    console.error(\"Exam Save Error:\", error);\n  }\n}"],"names":[],"mappings":"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"}},
    {"offset": {"line": 580, "column": 0}, "map": {"version":3,"sources":["file:///Users/emilyperez/Study%20App/my-study-app/.next-internal/server/app/page/actions.js%20%28server%20actions%20loader%29"],"sourcesContent":["export {uploadPdf as '4029b1f2a07c9a7d620d4b958168233797a4861b20'} from 'ACTIONS_MODULE0'\nexport {generateCrossword as '405f0c08a6259be969c69361ec5853ab9d7ccfe00c'} from 'ACTIONS_MODULE0'\nexport {generateStudyGuide as '409078de68a41a43e66f0601878397a73538990768'} from 'ACTIONS_MODULE0'\nexport {deleteCourse as '409b10a8f76ebde8a9c653283fd0b8db06b04e0359'} from 'ACTIONS_MODULE0'\nexport {generateFlashcards as '40b1056ec51f8d9f6ad6b2a3e1b600180be311da8d'} from 'ACTIONS_MODULE0'\nexport {generateQuiz as '40f43fc974ff6928b7b3a2e6912cea9dbb69f4517b'} from 'ACTIONS_MODULE0'\nexport {generatePracticeExam as '40fb690e8484cf7700be5874e06ca30bec5ad4966b'} from 'ACTIONS_MODULE0'\nexport {renameCourse as '604d9ab2e8562919b8dafb514e563e8e65bc7d7f81'} from 'ACTIONS_MODULE0'\nexport {saveQuizResult as '707237374e2ca69a57c875b3ea679e9f2e612c7182'} from 'ACTIONS_MODULE0'\nexport {saveExamResult as '70aae445aa96797072f5882989150971aec1840174'} from 'ACTIONS_MODULE0'\nexport {deleteCourse as '409b10a8f76ebde8a9c653283fd0b8db06b04e0359'} from 'ACTIONS_MODULE0'\nexport {renameCourse as '604d9ab2e8562919b8dafb514e563e8e65bc7d7f81'} from 'ACTIONS_MODULE0'\n"],"names":[],"mappings":";AAAA"}}]
}