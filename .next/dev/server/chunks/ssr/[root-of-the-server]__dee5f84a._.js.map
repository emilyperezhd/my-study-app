{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 10, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":""}},
    {"offset": {"line": 24, "column": 0}, "map": {"version":3,"sources":["file:///Users/emilyperez/Study%20App/my-study-app/src/app/actions.ts"],"sourcesContent":["'use server'\n\nimport { db } from \"../lib/db\";\nimport { revalidatePath } from \"next/cache\";\nimport { ChatOpenAI } from \"@langchain/openai\";\nimport { PromptTemplate } from \"@langchain/core/prompts\";\n\n// --- 1. BROWSER MOCKS (Prevents Crashes) ---\n// @ts-ignore\nif (!global.DOMMatrix) { global.DOMMatrix = class DOMMatrix { constructor() {} }; }\n// @ts-ignore\nif (!global.ImageData) { global.ImageData = class ImageData { constructor() {} }; }\n// @ts-ignore\nif (!global.Path2D) { global.Path2D = class Path2D { constructor() {} }; }\n\n// --- 2. SMART IMPORT ---\nlet pdfParse = require(\"pdf-parse\");\nif (typeof pdfParse !== 'function' && pdfParse.default) {\n    pdfParse = pdfParse.default;\n}\n\n// -----------------------------------------------------------\n\nexport async function uploadPdf(formData: FormData) {\n  try {\n    const file = formData.get(\"file\") as File;\n    if (!file) throw new Error(\"No file found\");\n\n    const arrayBuffer = await file.arrayBuffer();\n    const buffer = Buffer.from(arrayBuffer);\n\n    let finalContent = \"No text found.\";\n    \n    try {\n        const data = await pdfParse(buffer);\n        if (data && data.text && data.text.trim().length > 0) {\n            finalContent = data.text;\n        } else {\n            finalContent = \"⚠️ This PDF appears to be empty or scanned (image-only). Text could not be extracted.\";\n        }\n    } catch (parseError) {\n        console.error(\"PDF Parse Error:\", parseError);\n        finalContent = \"⚠️ Error parsing PDF. File might be corrupted or encrypted.\";\n    }\n\n    await db.course.create({\n      data: {\n        title: file.name,\n        content: finalContent,\n      }\n    });\n\n    revalidatePath(\"/\");\n  } catch (error) {\n    console.error(\"Upload Error:\", error);\n  }\n}\n\nexport async function generateStudyGuide(id: string) {\n  try {\n    const note = await db.course.findUnique({ where: { id: id } });\n    if (!note || !note.content) throw new Error(\"Note not found\");\n\n    const model = new ChatOpenAI({ \n      modelName: \"gpt-4o-mini\", \n      openAIApiKey: process.env.OPENAI_API_KEY \n    });\n\n    const prompt = PromptTemplate.fromTemplate(\n      `You are a strict academic tutor. Create a structured study guide.\n       Rules: HTML format only, use <h1>, <h2>, <ul>, <strong>. No Markdown.\n       Text: {text}`\n    );\n\n    const chain = prompt.pipe(model);\n    const response = await chain.invoke({ text: note.content.slice(0, 25000) });\n\n    await db.course.update({\n      where: { id: id },\n      data: { summary: response.content as string }\n    });\n\n    revalidatePath(`/notes/${id}`);\n  } catch (error) {\n    console.error(\"AI Study Guide Error:\", error);\n  }\n}\n\nexport async function generateQuiz(id: string) {\n  try {\n    const note = await db.course.findUnique({ where: { id: id } });\n    if (!note || !note.content) throw new Error(\"Note not found\");\n\n    const model = new ChatOpenAI({\n      modelName: \"gpt-4o-mini\",\n      openAIApiKey: process.env.OPENAI_API_KEY,\n      temperature: 0.1, \n      modelKwargs: { response_format: { type: \"json_object\" } } \n    });\n\n    const prompt = PromptTemplate.fromTemplate(\n      `Generate 5 difficult multiple-choice questions based on the provided text.\n       Return JSON object: {{ \"questions\": [ {{ \"question\": \"...\", \"options\": [\"...\"], \"answer\": \"...\" }} ] }}\n       Text: {text}`\n    );\n\n    const chain = prompt.pipe(model);\n    const response = await chain.invoke({ text: note.content.slice(0, 25000) });\n    \n    const content = typeof response.content === 'string' ? response.content : JSON.stringify(response.content);\n    const data = JSON.parse(content);\n    \n    await db.question.createMany({\n      data: data.questions.map((q: any) => ({\n        courseId: id,\n        question: q.question,\n        options: q.options,\n        answer: q.answer\n      }))\n    });\n\n    revalidatePath(`/notes/${id}`);\n  } catch (error) {\n    console.error(\"AI Quiz Error:\", error);\n  }\n}\n\nexport async function generateFlashcards(id: string) {\n  try {\n    const note = await db.course.findUnique({ where: { id: id } });\n    if (!note || !note.content) throw new Error(\"Note not found\");\n\n    const model = new ChatOpenAI({\n      modelName: \"gpt-4o-mini\",\n      openAIApiKey: process.env.OPENAI_API_KEY,\n      temperature: 0.1, \n      modelKwargs: { response_format: { type: \"json_object\" } } \n    });\n\n    const prompt = PromptTemplate.fromTemplate(\n      `Generate 15 study flashcards based on the provided text.\n       Focus on key definitions, formulas, and concepts.\n       Return JSON object: {{ \"flashcards\": [ {{ \"front\": \"Term\", \"back\": \"Definition\" }} ] }}\n       Text: {text}`\n    );\n\n    const chain = prompt.pipe(model);\n    const response = await chain.invoke({ text: note.content.slice(0, 25000) });\n    \n    const content = typeof response.content === 'string' ? response.content : JSON.stringify(response.content);\n    const data = JSON.parse(content);\n    \n    await db.flashcard.createMany({\n      data: data.flashcards.map((f: any) => ({\n        courseId: id,\n        front: f.front,\n        back: f.back\n      }))\n    });\n\n    revalidatePath(`/notes/${id}`);\n  } catch (error) {\n    console.error(\"Flashcard Gen Error:\", error);\n  }\n}\n\nexport async function generatePracticeExam(id: string) {\n  try {\n    const note = await db.course.findUnique({ where: { id: id } });\n    if (!note || !note.content) throw new Error(\"Note not found\");\n\n    const model = new ChatOpenAI({\n      modelName: \"gpt-4o-mini\",\n      openAIApiKey: process.env.OPENAI_API_KEY,\n      temperature: 0.1, \n      modelKwargs: { response_format: { type: \"json_object\" } } \n    });\n\n    const prompt = PromptTemplate.fromTemplate(\n      `Generate a Practice Midterm Exam with 20 difficult multiple-choice questions based on the text.\n       Include an \"explanation\" field explaining the correct answer.\n       Return JSON object: \n       {{ \"questions\": [ {{ \"question\": \"...\", \"options\": [\"...\"], \"answer\": \"...\", \"explanation\": \"...\" }} ] }}\n       Text: {text}`\n    );\n\n    const chain = prompt.pipe(model);\n    const response = await chain.invoke({ text: note.content.slice(0, 30000) });\n    \n    const content = typeof response.content === 'string' ? response.content : JSON.stringify(response.content);\n    const data = JSON.parse(content);\n    \n    await db.examQuestion.createMany({\n      data: data.questions.map((q: any) => ({\n        courseId: id,\n        question: q.question,\n        options: q.options,\n        answer: q.answer,\n        explanation: q.explanation\n      }))\n    });\n\n    revalidatePath(`/notes/${id}`);\n  } catch (error) {\n    console.error(\"Exam Gen Error:\", error);\n  }\n}\n\nexport async function generateCrossword(id: string) {\n  try {\n    const note = await db.course.findUnique({ where: { id: id } });\n    if (!note || !note.content) throw new Error(\"Note not found\");\n\n    const model = new ChatOpenAI({\n      modelName: \"gpt-4o\", // Stronger model for puzzles\n      openAIApiKey: process.env.OPENAI_API_KEY,\n      temperature: 0.1, \n      modelKwargs: { response_format: { type: \"json_object\" } } \n    });\n\n    // FIX: Using double curly braces {{ }} to escape the example JSON so LangChain doesn't crash\n    const prompt = PromptTemplate.fromTemplate(\n      `Generate a 10x10 Crossword Puzzle based on the provided text.\n       \n       Rules:\n       1. The grid must be 10x10.\n       2. Use standard crossword rules (words intersect).\n       3. Return a JSON object with:\n          - \"grid\": A 2D array (10 rows of 10 characters). Use '' (empty string) for black squares, single uppercase letters for filled.\n          - \"clues\": An object with \"across\" and \"down\" arrays. Each item: {{ \"number\": 1, \"clue\": \"...\" }}.\n          - \"numbers\": A 2D array (10x10) matching the grid. Put the clue number (1, 2...) in the start cell. 0 if none.\n       \n       Text content: {text}`\n    );\n\n    const chain = prompt.pipe(model);\n    const response = await chain.invoke({ text: note.content.slice(0, 30000) });\n    \n    const content = typeof response.content === 'string' ? response.content : JSON.stringify(response.content);\n    const data = JSON.parse(content);\n    \n    await db.crossword.create({\n      data: {\n        courseId: id,\n        puzzle: data\n      }\n    });\n\n    revalidatePath(`/notes/${id}`);\n  } catch (error) {\n    console.error(\"Crossword Gen Error:\", error);\n  }\n}\n\nexport async function saveQuizResult(courseId: string, score: number, total: number) {\n  try {\n    await db.quizResult.create({\n      data: { courseId, score, total },\n    });\n    revalidatePath(`/notes/${courseId}`);\n  } catch (error) {\n    console.error(\"Save Error:\", error);\n  }\n}\n\nexport async function saveExamResult(courseId: string, score: number, total: number) {\n  try {\n    await db.examResult.create({\n      data: { courseId, score, total },\n    });\n    revalidatePath(`/notes/${courseId}`);\n  } catch (error) {\n    console.error(\"Exam Save Error:\", error);\n  }\n}"],"names":[],"mappings":";;;;;;;IAuBsB,YAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA"}},
    {"offset": {"line": 36, "column": 0}, "map": {"version":3,"sources":["file:///Users/emilyperez/Study%20App/my-study-app/src/app/actions.ts"],"sourcesContent":["'use server'\n\nimport { db } from \"../lib/db\";\nimport { revalidatePath } from \"next/cache\";\nimport { ChatOpenAI } from \"@langchain/openai\";\nimport { PromptTemplate } from \"@langchain/core/prompts\";\n\n// --- 1. BROWSER MOCKS (Prevents Crashes) ---\n// @ts-ignore\nif (!global.DOMMatrix) { global.DOMMatrix = class DOMMatrix { constructor() {} }; }\n// @ts-ignore\nif (!global.ImageData) { global.ImageData = class ImageData { constructor() {} }; }\n// @ts-ignore\nif (!global.Path2D) { global.Path2D = class Path2D { constructor() {} }; }\n\n// --- 2. SMART IMPORT ---\nlet pdfParse = require(\"pdf-parse\");\nif (typeof pdfParse !== 'function' && pdfParse.default) {\n    pdfParse = pdfParse.default;\n}\n\n// -----------------------------------------------------------\n\nexport async function uploadPdf(formData: FormData) {\n  try {\n    const file = formData.get(\"file\") as File;\n    if (!file) throw new Error(\"No file found\");\n\n    const arrayBuffer = await file.arrayBuffer();\n    const buffer = Buffer.from(arrayBuffer);\n\n    let finalContent = \"No text found.\";\n    \n    try {\n        const data = await pdfParse(buffer);\n        if (data && data.text && data.text.trim().length > 0) {\n            finalContent = data.text;\n        } else {\n            finalContent = \"⚠️ This PDF appears to be empty or scanned (image-only). Text could not be extracted.\";\n        }\n    } catch (parseError) {\n        console.error(\"PDF Parse Error:\", parseError);\n        finalContent = \"⚠️ Error parsing PDF. File might be corrupted or encrypted.\";\n    }\n\n    await db.course.create({\n      data: {\n        title: file.name,\n        content: finalContent,\n      }\n    });\n\n    revalidatePath(\"/\");\n  } catch (error) {\n    console.error(\"Upload Error:\", error);\n  }\n}\n\nexport async function generateStudyGuide(id: string) {\n  try {\n    const note = await db.course.findUnique({ where: { id: id } });\n    if (!note || !note.content) throw new Error(\"Note not found\");\n\n    const model = new ChatOpenAI({ \n      modelName: \"gpt-4o-mini\", \n      openAIApiKey: process.env.OPENAI_API_KEY \n    });\n\n    const prompt = PromptTemplate.fromTemplate(\n      `You are a strict academic tutor. Create a structured study guide.\n       Rules: HTML format only, use <h1>, <h2>, <ul>, <strong>. No Markdown.\n       Text: {text}`\n    );\n\n    const chain = prompt.pipe(model);\n    const response = await chain.invoke({ text: note.content.slice(0, 25000) });\n\n    await db.course.update({\n      where: { id: id },\n      data: { summary: response.content as string }\n    });\n\n    revalidatePath(`/notes/${id}`);\n  } catch (error) {\n    console.error(\"AI Study Guide Error:\", error);\n  }\n}\n\nexport async function generateQuiz(id: string) {\n  try {\n    const note = await db.course.findUnique({ where: { id: id } });\n    if (!note || !note.content) throw new Error(\"Note not found\");\n\n    const model = new ChatOpenAI({\n      modelName: \"gpt-4o-mini\",\n      openAIApiKey: process.env.OPENAI_API_KEY,\n      temperature: 0.1, \n      modelKwargs: { response_format: { type: \"json_object\" } } \n    });\n\n    const prompt = PromptTemplate.fromTemplate(\n      `Generate 5 difficult multiple-choice questions based on the provided text.\n       Return JSON object: {{ \"questions\": [ {{ \"question\": \"...\", \"options\": [\"...\"], \"answer\": \"...\" }} ] }}\n       Text: {text}`\n    );\n\n    const chain = prompt.pipe(model);\n    const response = await chain.invoke({ text: note.content.slice(0, 25000) });\n    \n    const content = typeof response.content === 'string' ? response.content : JSON.stringify(response.content);\n    const data = JSON.parse(content);\n    \n    await db.question.createMany({\n      data: data.questions.map((q: any) => ({\n        courseId: id,\n        question: q.question,\n        options: q.options,\n        answer: q.answer\n      }))\n    });\n\n    revalidatePath(`/notes/${id}`);\n  } catch (error) {\n    console.error(\"AI Quiz Error:\", error);\n  }\n}\n\nexport async function generateFlashcards(id: string) {\n  try {\n    const note = await db.course.findUnique({ where: { id: id } });\n    if (!note || !note.content) throw new Error(\"Note not found\");\n\n    const model = new ChatOpenAI({\n      modelName: \"gpt-4o-mini\",\n      openAIApiKey: process.env.OPENAI_API_KEY,\n      temperature: 0.1, \n      modelKwargs: { response_format: { type: \"json_object\" } } \n    });\n\n    const prompt = PromptTemplate.fromTemplate(\n      `Generate 15 study flashcards based on the provided text.\n       Focus on key definitions, formulas, and concepts.\n       Return JSON object: {{ \"flashcards\": [ {{ \"front\": \"Term\", \"back\": \"Definition\" }} ] }}\n       Text: {text}`\n    );\n\n    const chain = prompt.pipe(model);\n    const response = await chain.invoke({ text: note.content.slice(0, 25000) });\n    \n    const content = typeof response.content === 'string' ? response.content : JSON.stringify(response.content);\n    const data = JSON.parse(content);\n    \n    await db.flashcard.createMany({\n      data: data.flashcards.map((f: any) => ({\n        courseId: id,\n        front: f.front,\n        back: f.back\n      }))\n    });\n\n    revalidatePath(`/notes/${id}`);\n  } catch (error) {\n    console.error(\"Flashcard Gen Error:\", error);\n  }\n}\n\nexport async function generatePracticeExam(id: string) {\n  try {\n    const note = await db.course.findUnique({ where: { id: id } });\n    if (!note || !note.content) throw new Error(\"Note not found\");\n\n    const model = new ChatOpenAI({\n      modelName: \"gpt-4o-mini\",\n      openAIApiKey: process.env.OPENAI_API_KEY,\n      temperature: 0.1, \n      modelKwargs: { response_format: { type: \"json_object\" } } \n    });\n\n    const prompt = PromptTemplate.fromTemplate(\n      `Generate a Practice Midterm Exam with 20 difficult multiple-choice questions based on the text.\n       Include an \"explanation\" field explaining the correct answer.\n       Return JSON object: \n       {{ \"questions\": [ {{ \"question\": \"...\", \"options\": [\"...\"], \"answer\": \"...\", \"explanation\": \"...\" }} ] }}\n       Text: {text}`\n    );\n\n    const chain = prompt.pipe(model);\n    const response = await chain.invoke({ text: note.content.slice(0, 30000) });\n    \n    const content = typeof response.content === 'string' ? response.content : JSON.stringify(response.content);\n    const data = JSON.parse(content);\n    \n    await db.examQuestion.createMany({\n      data: data.questions.map((q: any) => ({\n        courseId: id,\n        question: q.question,\n        options: q.options,\n        answer: q.answer,\n        explanation: q.explanation\n      }))\n    });\n\n    revalidatePath(`/notes/${id}`);\n  } catch (error) {\n    console.error(\"Exam Gen Error:\", error);\n  }\n}\n\nexport async function generateCrossword(id: string) {\n  try {\n    const note = await db.course.findUnique({ where: { id: id } });\n    if (!note || !note.content) throw new Error(\"Note not found\");\n\n    const model = new ChatOpenAI({\n      modelName: \"gpt-4o\", // Stronger model for puzzles\n      openAIApiKey: process.env.OPENAI_API_KEY,\n      temperature: 0.1, \n      modelKwargs: { response_format: { type: \"json_object\" } } \n    });\n\n    // FIX: Using double curly braces {{ }} to escape the example JSON so LangChain doesn't crash\n    const prompt = PromptTemplate.fromTemplate(\n      `Generate a 10x10 Crossword Puzzle based on the provided text.\n       \n       Rules:\n       1. The grid must be 10x10.\n       2. Use standard crossword rules (words intersect).\n       3. Return a JSON object with:\n          - \"grid\": A 2D array (10 rows of 10 characters). Use '' (empty string) for black squares, single uppercase letters for filled.\n          - \"clues\": An object with \"across\" and \"down\" arrays. Each item: {{ \"number\": 1, \"clue\": \"...\" }}.\n          - \"numbers\": A 2D array (10x10) matching the grid. Put the clue number (1, 2...) in the start cell. 0 if none.\n       \n       Text content: {text}`\n    );\n\n    const chain = prompt.pipe(model);\n    const response = await chain.invoke({ text: note.content.slice(0, 30000) });\n    \n    const content = typeof response.content === 'string' ? response.content : JSON.stringify(response.content);\n    const data = JSON.parse(content);\n    \n    await db.crossword.create({\n      data: {\n        courseId: id,\n        puzzle: data\n      }\n    });\n\n    revalidatePath(`/notes/${id}`);\n  } catch (error) {\n    console.error(\"Crossword Gen Error:\", error);\n  }\n}\n\nexport async function saveQuizResult(courseId: string, score: number, total: number) {\n  try {\n    await db.quizResult.create({\n      data: { courseId, score, total },\n    });\n    revalidatePath(`/notes/${courseId}`);\n  } catch (error) {\n    console.error(\"Save Error:\", error);\n  }\n}\n\nexport async function saveExamResult(courseId: string, score: number, total: number) {\n  try {\n    await db.examResult.create({\n      data: { courseId, score, total },\n    });\n    revalidatePath(`/notes/${courseId}`);\n  } catch (error) {\n    console.error(\"Exam Save Error:\", error);\n  }\n}"],"names":[],"mappings":";;;;;;;IA0DsB,qBAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA"}},
    {"offset": {"line": 48, "column": 0}, "map": {"version":3,"sources":["file:///Users/emilyperez/Study%20App/my-study-app/src/app/actions.ts"],"sourcesContent":["'use server'\n\nimport { db } from \"../lib/db\";\nimport { revalidatePath } from \"next/cache\";\nimport { ChatOpenAI } from \"@langchain/openai\";\nimport { PromptTemplate } from \"@langchain/core/prompts\";\n\n// --- 1. BROWSER MOCKS (Prevents Crashes) ---\n// @ts-ignore\nif (!global.DOMMatrix) { global.DOMMatrix = class DOMMatrix { constructor() {} }; }\n// @ts-ignore\nif (!global.ImageData) { global.ImageData = class ImageData { constructor() {} }; }\n// @ts-ignore\nif (!global.Path2D) { global.Path2D = class Path2D { constructor() {} }; }\n\n// --- 2. SMART IMPORT ---\nlet pdfParse = require(\"pdf-parse\");\nif (typeof pdfParse !== 'function' && pdfParse.default) {\n    pdfParse = pdfParse.default;\n}\n\n// -----------------------------------------------------------\n\nexport async function uploadPdf(formData: FormData) {\n  try {\n    const file = formData.get(\"file\") as File;\n    if (!file) throw new Error(\"No file found\");\n\n    const arrayBuffer = await file.arrayBuffer();\n    const buffer = Buffer.from(arrayBuffer);\n\n    let finalContent = \"No text found.\";\n    \n    try {\n        const data = await pdfParse(buffer);\n        if (data && data.text && data.text.trim().length > 0) {\n            finalContent = data.text;\n        } else {\n            finalContent = \"⚠️ This PDF appears to be empty or scanned (image-only). Text could not be extracted.\";\n        }\n    } catch (parseError) {\n        console.error(\"PDF Parse Error:\", parseError);\n        finalContent = \"⚠️ Error parsing PDF. File might be corrupted or encrypted.\";\n    }\n\n    await db.course.create({\n      data: {\n        title: file.name,\n        content: finalContent,\n      }\n    });\n\n    revalidatePath(\"/\");\n  } catch (error) {\n    console.error(\"Upload Error:\", error);\n  }\n}\n\nexport async function generateStudyGuide(id: string) {\n  try {\n    const note = await db.course.findUnique({ where: { id: id } });\n    if (!note || !note.content) throw new Error(\"Note not found\");\n\n    const model = new ChatOpenAI({ \n      modelName: \"gpt-4o-mini\", \n      openAIApiKey: process.env.OPENAI_API_KEY \n    });\n\n    const prompt = PromptTemplate.fromTemplate(\n      `You are a strict academic tutor. Create a structured study guide.\n       Rules: HTML format only, use <h1>, <h2>, <ul>, <strong>. No Markdown.\n       Text: {text}`\n    );\n\n    const chain = prompt.pipe(model);\n    const response = await chain.invoke({ text: note.content.slice(0, 25000) });\n\n    await db.course.update({\n      where: { id: id },\n      data: { summary: response.content as string }\n    });\n\n    revalidatePath(`/notes/${id}`);\n  } catch (error) {\n    console.error(\"AI Study Guide Error:\", error);\n  }\n}\n\nexport async function generateQuiz(id: string) {\n  try {\n    const note = await db.course.findUnique({ where: { id: id } });\n    if (!note || !note.content) throw new Error(\"Note not found\");\n\n    const model = new ChatOpenAI({\n      modelName: \"gpt-4o-mini\",\n      openAIApiKey: process.env.OPENAI_API_KEY,\n      temperature: 0.1, \n      modelKwargs: { response_format: { type: \"json_object\" } } \n    });\n\n    const prompt = PromptTemplate.fromTemplate(\n      `Generate 5 difficult multiple-choice questions based on the provided text.\n       Return JSON object: {{ \"questions\": [ {{ \"question\": \"...\", \"options\": [\"...\"], \"answer\": \"...\" }} ] }}\n       Text: {text}`\n    );\n\n    const chain = prompt.pipe(model);\n    const response = await chain.invoke({ text: note.content.slice(0, 25000) });\n    \n    const content = typeof response.content === 'string' ? response.content : JSON.stringify(response.content);\n    const data = JSON.parse(content);\n    \n    await db.question.createMany({\n      data: data.questions.map((q: any) => ({\n        courseId: id,\n        question: q.question,\n        options: q.options,\n        answer: q.answer\n      }))\n    });\n\n    revalidatePath(`/notes/${id}`);\n  } catch (error) {\n    console.error(\"AI Quiz Error:\", error);\n  }\n}\n\nexport async function generateFlashcards(id: string) {\n  try {\n    const note = await db.course.findUnique({ where: { id: id } });\n    if (!note || !note.content) throw new Error(\"Note not found\");\n\n    const model = new ChatOpenAI({\n      modelName: \"gpt-4o-mini\",\n      openAIApiKey: process.env.OPENAI_API_KEY,\n      temperature: 0.1, \n      modelKwargs: { response_format: { type: \"json_object\" } } \n    });\n\n    const prompt = PromptTemplate.fromTemplate(\n      `Generate 15 study flashcards based on the provided text.\n       Focus on key definitions, formulas, and concepts.\n       Return JSON object: {{ \"flashcards\": [ {{ \"front\": \"Term\", \"back\": \"Definition\" }} ] }}\n       Text: {text}`\n    );\n\n    const chain = prompt.pipe(model);\n    const response = await chain.invoke({ text: note.content.slice(0, 25000) });\n    \n    const content = typeof response.content === 'string' ? response.content : JSON.stringify(response.content);\n    const data = JSON.parse(content);\n    \n    await db.flashcard.createMany({\n      data: data.flashcards.map((f: any) => ({\n        courseId: id,\n        front: f.front,\n        back: f.back\n      }))\n    });\n\n    revalidatePath(`/notes/${id}`);\n  } catch (error) {\n    console.error(\"Flashcard Gen Error:\", error);\n  }\n}\n\nexport async function generatePracticeExam(id: string) {\n  try {\n    const note = await db.course.findUnique({ where: { id: id } });\n    if (!note || !note.content) throw new Error(\"Note not found\");\n\n    const model = new ChatOpenAI({\n      modelName: \"gpt-4o-mini\",\n      openAIApiKey: process.env.OPENAI_API_KEY,\n      temperature: 0.1, \n      modelKwargs: { response_format: { type: \"json_object\" } } \n    });\n\n    const prompt = PromptTemplate.fromTemplate(\n      `Generate a Practice Midterm Exam with 20 difficult multiple-choice questions based on the text.\n       Include an \"explanation\" field explaining the correct answer.\n       Return JSON object: \n       {{ \"questions\": [ {{ \"question\": \"...\", \"options\": [\"...\"], \"answer\": \"...\", \"explanation\": \"...\" }} ] }}\n       Text: {text}`\n    );\n\n    const chain = prompt.pipe(model);\n    const response = await chain.invoke({ text: note.content.slice(0, 30000) });\n    \n    const content = typeof response.content === 'string' ? response.content : JSON.stringify(response.content);\n    const data = JSON.parse(content);\n    \n    await db.examQuestion.createMany({\n      data: data.questions.map((q: any) => ({\n        courseId: id,\n        question: q.question,\n        options: q.options,\n        answer: q.answer,\n        explanation: q.explanation\n      }))\n    });\n\n    revalidatePath(`/notes/${id}`);\n  } catch (error) {\n    console.error(\"Exam Gen Error:\", error);\n  }\n}\n\nexport async function generateCrossword(id: string) {\n  try {\n    const note = await db.course.findUnique({ where: { id: id } });\n    if (!note || !note.content) throw new Error(\"Note not found\");\n\n    const model = new ChatOpenAI({\n      modelName: \"gpt-4o\", // Stronger model for puzzles\n      openAIApiKey: process.env.OPENAI_API_KEY,\n      temperature: 0.1, \n      modelKwargs: { response_format: { type: \"json_object\" } } \n    });\n\n    // FIX: Using double curly braces {{ }} to escape the example JSON so LangChain doesn't crash\n    const prompt = PromptTemplate.fromTemplate(\n      `Generate a 10x10 Crossword Puzzle based on the provided text.\n       \n       Rules:\n       1. The grid must be 10x10.\n       2. Use standard crossword rules (words intersect).\n       3. Return a JSON object with:\n          - \"grid\": A 2D array (10 rows of 10 characters). Use '' (empty string) for black squares, single uppercase letters for filled.\n          - \"clues\": An object with \"across\" and \"down\" arrays. Each item: {{ \"number\": 1, \"clue\": \"...\" }}.\n          - \"numbers\": A 2D array (10x10) matching the grid. Put the clue number (1, 2...) in the start cell. 0 if none.\n       \n       Text content: {text}`\n    );\n\n    const chain = prompt.pipe(model);\n    const response = await chain.invoke({ text: note.content.slice(0, 30000) });\n    \n    const content = typeof response.content === 'string' ? response.content : JSON.stringify(response.content);\n    const data = JSON.parse(content);\n    \n    await db.crossword.create({\n      data: {\n        courseId: id,\n        puzzle: data\n      }\n    });\n\n    revalidatePath(`/notes/${id}`);\n  } catch (error) {\n    console.error(\"Crossword Gen Error:\", error);\n  }\n}\n\nexport async function saveQuizResult(courseId: string, score: number, total: number) {\n  try {\n    await db.quizResult.create({\n      data: { courseId, score, total },\n    });\n    revalidatePath(`/notes/${courseId}`);\n  } catch (error) {\n    console.error(\"Save Error:\", error);\n  }\n}\n\nexport async function saveExamResult(courseId: string, score: number, total: number) {\n  try {\n    await db.examResult.create({\n      data: { courseId, score, total },\n    });\n    revalidatePath(`/notes/${courseId}`);\n  } catch (error) {\n    console.error(\"Exam Save Error:\", error);\n  }\n}"],"names":[],"mappings":";;;;;;;IAwFsB,eAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA"}},
    {"offset": {"line": 60, "column": 0}, "map": {"version":3,"sources":["file:///Users/emilyperez/Study%20App/my-study-app/src/app/actions.ts"],"sourcesContent":["'use server'\n\nimport { db } from \"../lib/db\";\nimport { revalidatePath } from \"next/cache\";\nimport { ChatOpenAI } from \"@langchain/openai\";\nimport { PromptTemplate } from \"@langchain/core/prompts\";\n\n// --- 1. BROWSER MOCKS (Prevents Crashes) ---\n// @ts-ignore\nif (!global.DOMMatrix) { global.DOMMatrix = class DOMMatrix { constructor() {} }; }\n// @ts-ignore\nif (!global.ImageData) { global.ImageData = class ImageData { constructor() {} }; }\n// @ts-ignore\nif (!global.Path2D) { global.Path2D = class Path2D { constructor() {} }; }\n\n// --- 2. SMART IMPORT ---\nlet pdfParse = require(\"pdf-parse\");\nif (typeof pdfParse !== 'function' && pdfParse.default) {\n    pdfParse = pdfParse.default;\n}\n\n// -----------------------------------------------------------\n\nexport async function uploadPdf(formData: FormData) {\n  try {\n    const file = formData.get(\"file\") as File;\n    if (!file) throw new Error(\"No file found\");\n\n    const arrayBuffer = await file.arrayBuffer();\n    const buffer = Buffer.from(arrayBuffer);\n\n    let finalContent = \"No text found.\";\n    \n    try {\n        const data = await pdfParse(buffer);\n        if (data && data.text && data.text.trim().length > 0) {\n            finalContent = data.text;\n        } else {\n            finalContent = \"⚠️ This PDF appears to be empty or scanned (image-only). Text could not be extracted.\";\n        }\n    } catch (parseError) {\n        console.error(\"PDF Parse Error:\", parseError);\n        finalContent = \"⚠️ Error parsing PDF. File might be corrupted or encrypted.\";\n    }\n\n    await db.course.create({\n      data: {\n        title: file.name,\n        content: finalContent,\n      }\n    });\n\n    revalidatePath(\"/\");\n  } catch (error) {\n    console.error(\"Upload Error:\", error);\n  }\n}\n\nexport async function generateStudyGuide(id: string) {\n  try {\n    const note = await db.course.findUnique({ where: { id: id } });\n    if (!note || !note.content) throw new Error(\"Note not found\");\n\n    const model = new ChatOpenAI({ \n      modelName: \"gpt-4o-mini\", \n      openAIApiKey: process.env.OPENAI_API_KEY \n    });\n\n    const prompt = PromptTemplate.fromTemplate(\n      `You are a strict academic tutor. Create a structured study guide.\n       Rules: HTML format only, use <h1>, <h2>, <ul>, <strong>. No Markdown.\n       Text: {text}`\n    );\n\n    const chain = prompt.pipe(model);\n    const response = await chain.invoke({ text: note.content.slice(0, 25000) });\n\n    await db.course.update({\n      where: { id: id },\n      data: { summary: response.content as string }\n    });\n\n    revalidatePath(`/notes/${id}`);\n  } catch (error) {\n    console.error(\"AI Study Guide Error:\", error);\n  }\n}\n\nexport async function generateQuiz(id: string) {\n  try {\n    const note = await db.course.findUnique({ where: { id: id } });\n    if (!note || !note.content) throw new Error(\"Note not found\");\n\n    const model = new ChatOpenAI({\n      modelName: \"gpt-4o-mini\",\n      openAIApiKey: process.env.OPENAI_API_KEY,\n      temperature: 0.1, \n      modelKwargs: { response_format: { type: \"json_object\" } } \n    });\n\n    const prompt = PromptTemplate.fromTemplate(\n      `Generate 5 difficult multiple-choice questions based on the provided text.\n       Return JSON object: {{ \"questions\": [ {{ \"question\": \"...\", \"options\": [\"...\"], \"answer\": \"...\" }} ] }}\n       Text: {text}`\n    );\n\n    const chain = prompt.pipe(model);\n    const response = await chain.invoke({ text: note.content.slice(0, 25000) });\n    \n    const content = typeof response.content === 'string' ? response.content : JSON.stringify(response.content);\n    const data = JSON.parse(content);\n    \n    await db.question.createMany({\n      data: data.questions.map((q: any) => ({\n        courseId: id,\n        question: q.question,\n        options: q.options,\n        answer: q.answer\n      }))\n    });\n\n    revalidatePath(`/notes/${id}`);\n  } catch (error) {\n    console.error(\"AI Quiz Error:\", error);\n  }\n}\n\nexport async function generateFlashcards(id: string) {\n  try {\n    const note = await db.course.findUnique({ where: { id: id } });\n    if (!note || !note.content) throw new Error(\"Note not found\");\n\n    const model = new ChatOpenAI({\n      modelName: \"gpt-4o-mini\",\n      openAIApiKey: process.env.OPENAI_API_KEY,\n      temperature: 0.1, \n      modelKwargs: { response_format: { type: \"json_object\" } } \n    });\n\n    const prompt = PromptTemplate.fromTemplate(\n      `Generate 15 study flashcards based on the provided text.\n       Focus on key definitions, formulas, and concepts.\n       Return JSON object: {{ \"flashcards\": [ {{ \"front\": \"Term\", \"back\": \"Definition\" }} ] }}\n       Text: {text}`\n    );\n\n    const chain = prompt.pipe(model);\n    const response = await chain.invoke({ text: note.content.slice(0, 25000) });\n    \n    const content = typeof response.content === 'string' ? response.content : JSON.stringify(response.content);\n    const data = JSON.parse(content);\n    \n    await db.flashcard.createMany({\n      data: data.flashcards.map((f: any) => ({\n        courseId: id,\n        front: f.front,\n        back: f.back\n      }))\n    });\n\n    revalidatePath(`/notes/${id}`);\n  } catch (error) {\n    console.error(\"Flashcard Gen Error:\", error);\n  }\n}\n\nexport async function generatePracticeExam(id: string) {\n  try {\n    const note = await db.course.findUnique({ where: { id: id } });\n    if (!note || !note.content) throw new Error(\"Note not found\");\n\n    const model = new ChatOpenAI({\n      modelName: \"gpt-4o-mini\",\n      openAIApiKey: process.env.OPENAI_API_KEY,\n      temperature: 0.1, \n      modelKwargs: { response_format: { type: \"json_object\" } } \n    });\n\n    const prompt = PromptTemplate.fromTemplate(\n      `Generate a Practice Midterm Exam with 20 difficult multiple-choice questions based on the text.\n       Include an \"explanation\" field explaining the correct answer.\n       Return JSON object: \n       {{ \"questions\": [ {{ \"question\": \"...\", \"options\": [\"...\"], \"answer\": \"...\", \"explanation\": \"...\" }} ] }}\n       Text: {text}`\n    );\n\n    const chain = prompt.pipe(model);\n    const response = await chain.invoke({ text: note.content.slice(0, 30000) });\n    \n    const content = typeof response.content === 'string' ? response.content : JSON.stringify(response.content);\n    const data = JSON.parse(content);\n    \n    await db.examQuestion.createMany({\n      data: data.questions.map((q: any) => ({\n        courseId: id,\n        question: q.question,\n        options: q.options,\n        answer: q.answer,\n        explanation: q.explanation\n      }))\n    });\n\n    revalidatePath(`/notes/${id}`);\n  } catch (error) {\n    console.error(\"Exam Gen Error:\", error);\n  }\n}\n\nexport async function generateCrossword(id: string) {\n  try {\n    const note = await db.course.findUnique({ where: { id: id } });\n    if (!note || !note.content) throw new Error(\"Note not found\");\n\n    const model = new ChatOpenAI({\n      modelName: \"gpt-4o\", // Stronger model for puzzles\n      openAIApiKey: process.env.OPENAI_API_KEY,\n      temperature: 0.1, \n      modelKwargs: { response_format: { type: \"json_object\" } } \n    });\n\n    // FIX: Using double curly braces {{ }} to escape the example JSON so LangChain doesn't crash\n    const prompt = PromptTemplate.fromTemplate(\n      `Generate a 10x10 Crossword Puzzle based on the provided text.\n       \n       Rules:\n       1. The grid must be 10x10.\n       2. Use standard crossword rules (words intersect).\n       3. Return a JSON object with:\n          - \"grid\": A 2D array (10 rows of 10 characters). Use '' (empty string) for black squares, single uppercase letters for filled.\n          - \"clues\": An object with \"across\" and \"down\" arrays. Each item: {{ \"number\": 1, \"clue\": \"...\" }}.\n          - \"numbers\": A 2D array (10x10) matching the grid. Put the clue number (1, 2...) in the start cell. 0 if none.\n       \n       Text content: {text}`\n    );\n\n    const chain = prompt.pipe(model);\n    const response = await chain.invoke({ text: note.content.slice(0, 30000) });\n    \n    const content = typeof response.content === 'string' ? response.content : JSON.stringify(response.content);\n    const data = JSON.parse(content);\n    \n    await db.crossword.create({\n      data: {\n        courseId: id,\n        puzzle: data\n      }\n    });\n\n    revalidatePath(`/notes/${id}`);\n  } catch (error) {\n    console.error(\"Crossword Gen Error:\", error);\n  }\n}\n\nexport async function saveQuizResult(courseId: string, score: number, total: number) {\n  try {\n    await db.quizResult.create({\n      data: { courseId, score, total },\n    });\n    revalidatePath(`/notes/${courseId}`);\n  } catch (error) {\n    console.error(\"Save Error:\", error);\n  }\n}\n\nexport async function saveExamResult(courseId: string, score: number, total: number) {\n  try {\n    await db.examResult.create({\n      data: { courseId, score, total },\n    });\n    revalidatePath(`/notes/${courseId}`);\n  } catch (error) {\n    console.error(\"Exam Save Error:\", error);\n  }\n}"],"names":[],"mappings":";;;;;;;IA+HsB,qBAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA"}},
    {"offset": {"line": 72, "column": 0}, "map": {"version":3,"sources":["file:///Users/emilyperez/Study%20App/my-study-app/src/app/actions.ts"],"sourcesContent":["'use server'\n\nimport { db } from \"../lib/db\";\nimport { revalidatePath } from \"next/cache\";\nimport { ChatOpenAI } from \"@langchain/openai\";\nimport { PromptTemplate } from \"@langchain/core/prompts\";\n\n// --- 1. BROWSER MOCKS (Prevents Crashes) ---\n// @ts-ignore\nif (!global.DOMMatrix) { global.DOMMatrix = class DOMMatrix { constructor() {} }; }\n// @ts-ignore\nif (!global.ImageData) { global.ImageData = class ImageData { constructor() {} }; }\n// @ts-ignore\nif (!global.Path2D) { global.Path2D = class Path2D { constructor() {} }; }\n\n// --- 2. SMART IMPORT ---\nlet pdfParse = require(\"pdf-parse\");\nif (typeof pdfParse !== 'function' && pdfParse.default) {\n    pdfParse = pdfParse.default;\n}\n\n// -----------------------------------------------------------\n\nexport async function uploadPdf(formData: FormData) {\n  try {\n    const file = formData.get(\"file\") as File;\n    if (!file) throw new Error(\"No file found\");\n\n    const arrayBuffer = await file.arrayBuffer();\n    const buffer = Buffer.from(arrayBuffer);\n\n    let finalContent = \"No text found.\";\n    \n    try {\n        const data = await pdfParse(buffer);\n        if (data && data.text && data.text.trim().length > 0) {\n            finalContent = data.text;\n        } else {\n            finalContent = \"⚠️ This PDF appears to be empty or scanned (image-only). Text could not be extracted.\";\n        }\n    } catch (parseError) {\n        console.error(\"PDF Parse Error:\", parseError);\n        finalContent = \"⚠️ Error parsing PDF. File might be corrupted or encrypted.\";\n    }\n\n    await db.course.create({\n      data: {\n        title: file.name,\n        content: finalContent,\n      }\n    });\n\n    revalidatePath(\"/\");\n  } catch (error) {\n    console.error(\"Upload Error:\", error);\n  }\n}\n\nexport async function generateStudyGuide(id: string) {\n  try {\n    const note = await db.course.findUnique({ where: { id: id } });\n    if (!note || !note.content) throw new Error(\"Note not found\");\n\n    const model = new ChatOpenAI({ \n      modelName: \"gpt-4o-mini\", \n      openAIApiKey: process.env.OPENAI_API_KEY \n    });\n\n    const prompt = PromptTemplate.fromTemplate(\n      `You are a strict academic tutor. Create a structured study guide.\n       Rules: HTML format only, use <h1>, <h2>, <ul>, <strong>. No Markdown.\n       Text: {text}`\n    );\n\n    const chain = prompt.pipe(model);\n    const response = await chain.invoke({ text: note.content.slice(0, 25000) });\n\n    await db.course.update({\n      where: { id: id },\n      data: { summary: response.content as string }\n    });\n\n    revalidatePath(`/notes/${id}`);\n  } catch (error) {\n    console.error(\"AI Study Guide Error:\", error);\n  }\n}\n\nexport async function generateQuiz(id: string) {\n  try {\n    const note = await db.course.findUnique({ where: { id: id } });\n    if (!note || !note.content) throw new Error(\"Note not found\");\n\n    const model = new ChatOpenAI({\n      modelName: \"gpt-4o-mini\",\n      openAIApiKey: process.env.OPENAI_API_KEY,\n      temperature: 0.1, \n      modelKwargs: { response_format: { type: \"json_object\" } } \n    });\n\n    const prompt = PromptTemplate.fromTemplate(\n      `Generate 5 difficult multiple-choice questions based on the provided text.\n       Return JSON object: {{ \"questions\": [ {{ \"question\": \"...\", \"options\": [\"...\"], \"answer\": \"...\" }} ] }}\n       Text: {text}`\n    );\n\n    const chain = prompt.pipe(model);\n    const response = await chain.invoke({ text: note.content.slice(0, 25000) });\n    \n    const content = typeof response.content === 'string' ? response.content : JSON.stringify(response.content);\n    const data = JSON.parse(content);\n    \n    await db.question.createMany({\n      data: data.questions.map((q: any) => ({\n        courseId: id,\n        question: q.question,\n        options: q.options,\n        answer: q.answer\n      }))\n    });\n\n    revalidatePath(`/notes/${id}`);\n  } catch (error) {\n    console.error(\"AI Quiz Error:\", error);\n  }\n}\n\nexport async function generateFlashcards(id: string) {\n  try {\n    const note = await db.course.findUnique({ where: { id: id } });\n    if (!note || !note.content) throw new Error(\"Note not found\");\n\n    const model = new ChatOpenAI({\n      modelName: \"gpt-4o-mini\",\n      openAIApiKey: process.env.OPENAI_API_KEY,\n      temperature: 0.1, \n      modelKwargs: { response_format: { type: \"json_object\" } } \n    });\n\n    const prompt = PromptTemplate.fromTemplate(\n      `Generate 15 study flashcards based on the provided text.\n       Focus on key definitions, formulas, and concepts.\n       Return JSON object: {{ \"flashcards\": [ {{ \"front\": \"Term\", \"back\": \"Definition\" }} ] }}\n       Text: {text}`\n    );\n\n    const chain = prompt.pipe(model);\n    const response = await chain.invoke({ text: note.content.slice(0, 25000) });\n    \n    const content = typeof response.content === 'string' ? response.content : JSON.stringify(response.content);\n    const data = JSON.parse(content);\n    \n    await db.flashcard.createMany({\n      data: data.flashcards.map((f: any) => ({\n        courseId: id,\n        front: f.front,\n        back: f.back\n      }))\n    });\n\n    revalidatePath(`/notes/${id}`);\n  } catch (error) {\n    console.error(\"Flashcard Gen Error:\", error);\n  }\n}\n\nexport async function generatePracticeExam(id: string) {\n  try {\n    const note = await db.course.findUnique({ where: { id: id } });\n    if (!note || !note.content) throw new Error(\"Note not found\");\n\n    const model = new ChatOpenAI({\n      modelName: \"gpt-4o-mini\",\n      openAIApiKey: process.env.OPENAI_API_KEY,\n      temperature: 0.1, \n      modelKwargs: { response_format: { type: \"json_object\" } } \n    });\n\n    const prompt = PromptTemplate.fromTemplate(\n      `Generate a Practice Midterm Exam with 20 difficult multiple-choice questions based on the text.\n       Include an \"explanation\" field explaining the correct answer.\n       Return JSON object: \n       {{ \"questions\": [ {{ \"question\": \"...\", \"options\": [\"...\"], \"answer\": \"...\", \"explanation\": \"...\" }} ] }}\n       Text: {text}`\n    );\n\n    const chain = prompt.pipe(model);\n    const response = await chain.invoke({ text: note.content.slice(0, 30000) });\n    \n    const content = typeof response.content === 'string' ? response.content : JSON.stringify(response.content);\n    const data = JSON.parse(content);\n    \n    await db.examQuestion.createMany({\n      data: data.questions.map((q: any) => ({\n        courseId: id,\n        question: q.question,\n        options: q.options,\n        answer: q.answer,\n        explanation: q.explanation\n      }))\n    });\n\n    revalidatePath(`/notes/${id}`);\n  } catch (error) {\n    console.error(\"Exam Gen Error:\", error);\n  }\n}\n\nexport async function generateCrossword(id: string) {\n  try {\n    const note = await db.course.findUnique({ where: { id: id } });\n    if (!note || !note.content) throw new Error(\"Note not found\");\n\n    const model = new ChatOpenAI({\n      modelName: \"gpt-4o\", // Stronger model for puzzles\n      openAIApiKey: process.env.OPENAI_API_KEY,\n      temperature: 0.1, \n      modelKwargs: { response_format: { type: \"json_object\" } } \n    });\n\n    // FIX: Using double curly braces {{ }} to escape the example JSON so LangChain doesn't crash\n    const prompt = PromptTemplate.fromTemplate(\n      `Generate a 10x10 Crossword Puzzle based on the provided text.\n       \n       Rules:\n       1. The grid must be 10x10.\n       2. Use standard crossword rules (words intersect).\n       3. Return a JSON object with:\n          - \"grid\": A 2D array (10 rows of 10 characters). Use '' (empty string) for black squares, single uppercase letters for filled.\n          - \"clues\": An object with \"across\" and \"down\" arrays. Each item: {{ \"number\": 1, \"clue\": \"...\" }}.\n          - \"numbers\": A 2D array (10x10) matching the grid. Put the clue number (1, 2...) in the start cell. 0 if none.\n       \n       Text content: {text}`\n    );\n\n    const chain = prompt.pipe(model);\n    const response = await chain.invoke({ text: note.content.slice(0, 30000) });\n    \n    const content = typeof response.content === 'string' ? response.content : JSON.stringify(response.content);\n    const data = JSON.parse(content);\n    \n    await db.crossword.create({\n      data: {\n        courseId: id,\n        puzzle: data\n      }\n    });\n\n    revalidatePath(`/notes/${id}`);\n  } catch (error) {\n    console.error(\"Crossword Gen Error:\", error);\n  }\n}\n\nexport async function saveQuizResult(courseId: string, score: number, total: number) {\n  try {\n    await db.quizResult.create({\n      data: { courseId, score, total },\n    });\n    revalidatePath(`/notes/${courseId}`);\n  } catch (error) {\n    console.error(\"Save Error:\", error);\n  }\n}\n\nexport async function saveExamResult(courseId: string, score: number, total: number) {\n  try {\n    await db.examResult.create({\n      data: { courseId, score, total },\n    });\n    revalidatePath(`/notes/${courseId}`);\n  } catch (error) {\n    console.error(\"Exam Save Error:\", error);\n  }\n}"],"names":[],"mappings":";;;;;;;IAsKsB,uBAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA"}},
    {"offset": {"line": 84, "column": 0}, "map": {"version":3,"sources":["file:///Users/emilyperez/Study%20App/my-study-app/src/app/actions.ts"],"sourcesContent":["'use server'\n\nimport { db } from \"../lib/db\";\nimport { revalidatePath } from \"next/cache\";\nimport { ChatOpenAI } from \"@langchain/openai\";\nimport { PromptTemplate } from \"@langchain/core/prompts\";\n\n// --- 1. BROWSER MOCKS (Prevents Crashes) ---\n// @ts-ignore\nif (!global.DOMMatrix) { global.DOMMatrix = class DOMMatrix { constructor() {} }; }\n// @ts-ignore\nif (!global.ImageData) { global.ImageData = class ImageData { constructor() {} }; }\n// @ts-ignore\nif (!global.Path2D) { global.Path2D = class Path2D { constructor() {} }; }\n\n// --- 2. SMART IMPORT ---\nlet pdfParse = require(\"pdf-parse\");\nif (typeof pdfParse !== 'function' && pdfParse.default) {\n    pdfParse = pdfParse.default;\n}\n\n// -----------------------------------------------------------\n\nexport async function uploadPdf(formData: FormData) {\n  try {\n    const file = formData.get(\"file\") as File;\n    if (!file) throw new Error(\"No file found\");\n\n    const arrayBuffer = await file.arrayBuffer();\n    const buffer = Buffer.from(arrayBuffer);\n\n    let finalContent = \"No text found.\";\n    \n    try {\n        const data = await pdfParse(buffer);\n        if (data && data.text && data.text.trim().length > 0) {\n            finalContent = data.text;\n        } else {\n            finalContent = \"⚠️ This PDF appears to be empty or scanned (image-only). Text could not be extracted.\";\n        }\n    } catch (parseError) {\n        console.error(\"PDF Parse Error:\", parseError);\n        finalContent = \"⚠️ Error parsing PDF. File might be corrupted or encrypted.\";\n    }\n\n    await db.course.create({\n      data: {\n        title: file.name,\n        content: finalContent,\n      }\n    });\n\n    revalidatePath(\"/\");\n  } catch (error) {\n    console.error(\"Upload Error:\", error);\n  }\n}\n\nexport async function generateStudyGuide(id: string) {\n  try {\n    const note = await db.course.findUnique({ where: { id: id } });\n    if (!note || !note.content) throw new Error(\"Note not found\");\n\n    const model = new ChatOpenAI({ \n      modelName: \"gpt-4o-mini\", \n      openAIApiKey: process.env.OPENAI_API_KEY \n    });\n\n    const prompt = PromptTemplate.fromTemplate(\n      `You are a strict academic tutor. Create a structured study guide.\n       Rules: HTML format only, use <h1>, <h2>, <ul>, <strong>. No Markdown.\n       Text: {text}`\n    );\n\n    const chain = prompt.pipe(model);\n    const response = await chain.invoke({ text: note.content.slice(0, 25000) });\n\n    await db.course.update({\n      where: { id: id },\n      data: { summary: response.content as string }\n    });\n\n    revalidatePath(`/notes/${id}`);\n  } catch (error) {\n    console.error(\"AI Study Guide Error:\", error);\n  }\n}\n\nexport async function generateQuiz(id: string) {\n  try {\n    const note = await db.course.findUnique({ where: { id: id } });\n    if (!note || !note.content) throw new Error(\"Note not found\");\n\n    const model = new ChatOpenAI({\n      modelName: \"gpt-4o-mini\",\n      openAIApiKey: process.env.OPENAI_API_KEY,\n      temperature: 0.1, \n      modelKwargs: { response_format: { type: \"json_object\" } } \n    });\n\n    const prompt = PromptTemplate.fromTemplate(\n      `Generate 5 difficult multiple-choice questions based on the provided text.\n       Return JSON object: {{ \"questions\": [ {{ \"question\": \"...\", \"options\": [\"...\"], \"answer\": \"...\" }} ] }}\n       Text: {text}`\n    );\n\n    const chain = prompt.pipe(model);\n    const response = await chain.invoke({ text: note.content.slice(0, 25000) });\n    \n    const content = typeof response.content === 'string' ? response.content : JSON.stringify(response.content);\n    const data = JSON.parse(content);\n    \n    await db.question.createMany({\n      data: data.questions.map((q: any) => ({\n        courseId: id,\n        question: q.question,\n        options: q.options,\n        answer: q.answer\n      }))\n    });\n\n    revalidatePath(`/notes/${id}`);\n  } catch (error) {\n    console.error(\"AI Quiz Error:\", error);\n  }\n}\n\nexport async function generateFlashcards(id: string) {\n  try {\n    const note = await db.course.findUnique({ where: { id: id } });\n    if (!note || !note.content) throw new Error(\"Note not found\");\n\n    const model = new ChatOpenAI({\n      modelName: \"gpt-4o-mini\",\n      openAIApiKey: process.env.OPENAI_API_KEY,\n      temperature: 0.1, \n      modelKwargs: { response_format: { type: \"json_object\" } } \n    });\n\n    const prompt = PromptTemplate.fromTemplate(\n      `Generate 15 study flashcards based on the provided text.\n       Focus on key definitions, formulas, and concepts.\n       Return JSON object: {{ \"flashcards\": [ {{ \"front\": \"Term\", \"back\": \"Definition\" }} ] }}\n       Text: {text}`\n    );\n\n    const chain = prompt.pipe(model);\n    const response = await chain.invoke({ text: note.content.slice(0, 25000) });\n    \n    const content = typeof response.content === 'string' ? response.content : JSON.stringify(response.content);\n    const data = JSON.parse(content);\n    \n    await db.flashcard.createMany({\n      data: data.flashcards.map((f: any) => ({\n        courseId: id,\n        front: f.front,\n        back: f.back\n      }))\n    });\n\n    revalidatePath(`/notes/${id}`);\n  } catch (error) {\n    console.error(\"Flashcard Gen Error:\", error);\n  }\n}\n\nexport async function generatePracticeExam(id: string) {\n  try {\n    const note = await db.course.findUnique({ where: { id: id } });\n    if (!note || !note.content) throw new Error(\"Note not found\");\n\n    const model = new ChatOpenAI({\n      modelName: \"gpt-4o-mini\",\n      openAIApiKey: process.env.OPENAI_API_KEY,\n      temperature: 0.1, \n      modelKwargs: { response_format: { type: \"json_object\" } } \n    });\n\n    const prompt = PromptTemplate.fromTemplate(\n      `Generate a Practice Midterm Exam with 20 difficult multiple-choice questions based on the text.\n       Include an \"explanation\" field explaining the correct answer.\n       Return JSON object: \n       {{ \"questions\": [ {{ \"question\": \"...\", \"options\": [\"...\"], \"answer\": \"...\", \"explanation\": \"...\" }} ] }}\n       Text: {text}`\n    );\n\n    const chain = prompt.pipe(model);\n    const response = await chain.invoke({ text: note.content.slice(0, 30000) });\n    \n    const content = typeof response.content === 'string' ? response.content : JSON.stringify(response.content);\n    const data = JSON.parse(content);\n    \n    await db.examQuestion.createMany({\n      data: data.questions.map((q: any) => ({\n        courseId: id,\n        question: q.question,\n        options: q.options,\n        answer: q.answer,\n        explanation: q.explanation\n      }))\n    });\n\n    revalidatePath(`/notes/${id}`);\n  } catch (error) {\n    console.error(\"Exam Gen Error:\", error);\n  }\n}\n\nexport async function generateCrossword(id: string) {\n  try {\n    const note = await db.course.findUnique({ where: { id: id } });\n    if (!note || !note.content) throw new Error(\"Note not found\");\n\n    const model = new ChatOpenAI({\n      modelName: \"gpt-4o\", // Stronger model for puzzles\n      openAIApiKey: process.env.OPENAI_API_KEY,\n      temperature: 0.1, \n      modelKwargs: { response_format: { type: \"json_object\" } } \n    });\n\n    // FIX: Using double curly braces {{ }} to escape the example JSON so LangChain doesn't crash\n    const prompt = PromptTemplate.fromTemplate(\n      `Generate a 10x10 Crossword Puzzle based on the provided text.\n       \n       Rules:\n       1. The grid must be 10x10.\n       2. Use standard crossword rules (words intersect).\n       3. Return a JSON object with:\n          - \"grid\": A 2D array (10 rows of 10 characters). Use '' (empty string) for black squares, single uppercase letters for filled.\n          - \"clues\": An object with \"across\" and \"down\" arrays. Each item: {{ \"number\": 1, \"clue\": \"...\" }}.\n          - \"numbers\": A 2D array (10x10) matching the grid. Put the clue number (1, 2...) in the start cell. 0 if none.\n       \n       Text content: {text}`\n    );\n\n    const chain = prompt.pipe(model);\n    const response = await chain.invoke({ text: note.content.slice(0, 30000) });\n    \n    const content = typeof response.content === 'string' ? response.content : JSON.stringify(response.content);\n    const data = JSON.parse(content);\n    \n    await db.crossword.create({\n      data: {\n        courseId: id,\n        puzzle: data\n      }\n    });\n\n    revalidatePath(`/notes/${id}`);\n  } catch (error) {\n    console.error(\"Crossword Gen Error:\", error);\n  }\n}\n\nexport async function saveQuizResult(courseId: string, score: number, total: number) {\n  try {\n    await db.quizResult.create({\n      data: { courseId, score, total },\n    });\n    revalidatePath(`/notes/${courseId}`);\n  } catch (error) {\n    console.error(\"Save Error:\", error);\n  }\n}\n\nexport async function saveExamResult(courseId: string, score: number, total: number) {\n  try {\n    await db.examResult.create({\n      data: { courseId, score, total },\n    });\n    revalidatePath(`/notes/${courseId}`);\n  } catch (error) {\n    console.error(\"Exam Save Error:\", error);\n  }\n}"],"names":[],"mappings":";;;;;;;IAgNsB,oBAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA"}},
    {"offset": {"line": 96, "column": 0}, "map": {"version":3,"sources":["file:///Users/emilyperez/Study%20App/my-study-app/src/app/actions.ts"],"sourcesContent":["'use server'\n\nimport { db } from \"../lib/db\";\nimport { revalidatePath } from \"next/cache\";\nimport { ChatOpenAI } from \"@langchain/openai\";\nimport { PromptTemplate } from \"@langchain/core/prompts\";\n\n// --- 1. BROWSER MOCKS (Prevents Crashes) ---\n// @ts-ignore\nif (!global.DOMMatrix) { global.DOMMatrix = class DOMMatrix { constructor() {} }; }\n// @ts-ignore\nif (!global.ImageData) { global.ImageData = class ImageData { constructor() {} }; }\n// @ts-ignore\nif (!global.Path2D) { global.Path2D = class Path2D { constructor() {} }; }\n\n// --- 2. SMART IMPORT ---\nlet pdfParse = require(\"pdf-parse\");\nif (typeof pdfParse !== 'function' && pdfParse.default) {\n    pdfParse = pdfParse.default;\n}\n\n// -----------------------------------------------------------\n\nexport async function uploadPdf(formData: FormData) {\n  try {\n    const file = formData.get(\"file\") as File;\n    if (!file) throw new Error(\"No file found\");\n\n    const arrayBuffer = await file.arrayBuffer();\n    const buffer = Buffer.from(arrayBuffer);\n\n    let finalContent = \"No text found.\";\n    \n    try {\n        const data = await pdfParse(buffer);\n        if (data && data.text && data.text.trim().length > 0) {\n            finalContent = data.text;\n        } else {\n            finalContent = \"⚠️ This PDF appears to be empty or scanned (image-only). Text could not be extracted.\";\n        }\n    } catch (parseError) {\n        console.error(\"PDF Parse Error:\", parseError);\n        finalContent = \"⚠️ Error parsing PDF. File might be corrupted or encrypted.\";\n    }\n\n    await db.course.create({\n      data: {\n        title: file.name,\n        content: finalContent,\n      }\n    });\n\n    revalidatePath(\"/\");\n  } catch (error) {\n    console.error(\"Upload Error:\", error);\n  }\n}\n\nexport async function generateStudyGuide(id: string) {\n  try {\n    const note = await db.course.findUnique({ where: { id: id } });\n    if (!note || !note.content) throw new Error(\"Note not found\");\n\n    const model = new ChatOpenAI({ \n      modelName: \"gpt-4o-mini\", \n      openAIApiKey: process.env.OPENAI_API_KEY \n    });\n\n    const prompt = PromptTemplate.fromTemplate(\n      `You are a strict academic tutor. Create a structured study guide.\n       Rules: HTML format only, use <h1>, <h2>, <ul>, <strong>. No Markdown.\n       Text: {text}`\n    );\n\n    const chain = prompt.pipe(model);\n    const response = await chain.invoke({ text: note.content.slice(0, 25000) });\n\n    await db.course.update({\n      where: { id: id },\n      data: { summary: response.content as string }\n    });\n\n    revalidatePath(`/notes/${id}`);\n  } catch (error) {\n    console.error(\"AI Study Guide Error:\", error);\n  }\n}\n\nexport async function generateQuiz(id: string) {\n  try {\n    const note = await db.course.findUnique({ where: { id: id } });\n    if (!note || !note.content) throw new Error(\"Note not found\");\n\n    const model = new ChatOpenAI({\n      modelName: \"gpt-4o-mini\",\n      openAIApiKey: process.env.OPENAI_API_KEY,\n      temperature: 0.1, \n      modelKwargs: { response_format: { type: \"json_object\" } } \n    });\n\n    const prompt = PromptTemplate.fromTemplate(\n      `Generate 5 difficult multiple-choice questions based on the provided text.\n       Return JSON object: {{ \"questions\": [ {{ \"question\": \"...\", \"options\": [\"...\"], \"answer\": \"...\" }} ] }}\n       Text: {text}`\n    );\n\n    const chain = prompt.pipe(model);\n    const response = await chain.invoke({ text: note.content.slice(0, 25000) });\n    \n    const content = typeof response.content === 'string' ? response.content : JSON.stringify(response.content);\n    const data = JSON.parse(content);\n    \n    await db.question.createMany({\n      data: data.questions.map((q: any) => ({\n        courseId: id,\n        question: q.question,\n        options: q.options,\n        answer: q.answer\n      }))\n    });\n\n    revalidatePath(`/notes/${id}`);\n  } catch (error) {\n    console.error(\"AI Quiz Error:\", error);\n  }\n}\n\nexport async function generateFlashcards(id: string) {\n  try {\n    const note = await db.course.findUnique({ where: { id: id } });\n    if (!note || !note.content) throw new Error(\"Note not found\");\n\n    const model = new ChatOpenAI({\n      modelName: \"gpt-4o-mini\",\n      openAIApiKey: process.env.OPENAI_API_KEY,\n      temperature: 0.1, \n      modelKwargs: { response_format: { type: \"json_object\" } } \n    });\n\n    const prompt = PromptTemplate.fromTemplate(\n      `Generate 15 study flashcards based on the provided text.\n       Focus on key definitions, formulas, and concepts.\n       Return JSON object: {{ \"flashcards\": [ {{ \"front\": \"Term\", \"back\": \"Definition\" }} ] }}\n       Text: {text}`\n    );\n\n    const chain = prompt.pipe(model);\n    const response = await chain.invoke({ text: note.content.slice(0, 25000) });\n    \n    const content = typeof response.content === 'string' ? response.content : JSON.stringify(response.content);\n    const data = JSON.parse(content);\n    \n    await db.flashcard.createMany({\n      data: data.flashcards.map((f: any) => ({\n        courseId: id,\n        front: f.front,\n        back: f.back\n      }))\n    });\n\n    revalidatePath(`/notes/${id}`);\n  } catch (error) {\n    console.error(\"Flashcard Gen Error:\", error);\n  }\n}\n\nexport async function generatePracticeExam(id: string) {\n  try {\n    const note = await db.course.findUnique({ where: { id: id } });\n    if (!note || !note.content) throw new Error(\"Note not found\");\n\n    const model = new ChatOpenAI({\n      modelName: \"gpt-4o-mini\",\n      openAIApiKey: process.env.OPENAI_API_KEY,\n      temperature: 0.1, \n      modelKwargs: { response_format: { type: \"json_object\" } } \n    });\n\n    const prompt = PromptTemplate.fromTemplate(\n      `Generate a Practice Midterm Exam with 20 difficult multiple-choice questions based on the text.\n       Include an \"explanation\" field explaining the correct answer.\n       Return JSON object: \n       {{ \"questions\": [ {{ \"question\": \"...\", \"options\": [\"...\"], \"answer\": \"...\", \"explanation\": \"...\" }} ] }}\n       Text: {text}`\n    );\n\n    const chain = prompt.pipe(model);\n    const response = await chain.invoke({ text: note.content.slice(0, 30000) });\n    \n    const content = typeof response.content === 'string' ? response.content : JSON.stringify(response.content);\n    const data = JSON.parse(content);\n    \n    await db.examQuestion.createMany({\n      data: data.questions.map((q: any) => ({\n        courseId: id,\n        question: q.question,\n        options: q.options,\n        answer: q.answer,\n        explanation: q.explanation\n      }))\n    });\n\n    revalidatePath(`/notes/${id}`);\n  } catch (error) {\n    console.error(\"Exam Gen Error:\", error);\n  }\n}\n\nexport async function generateCrossword(id: string) {\n  try {\n    const note = await db.course.findUnique({ where: { id: id } });\n    if (!note || !note.content) throw new Error(\"Note not found\");\n\n    const model = new ChatOpenAI({\n      modelName: \"gpt-4o\", // Stronger model for puzzles\n      openAIApiKey: process.env.OPENAI_API_KEY,\n      temperature: 0.1, \n      modelKwargs: { response_format: { type: \"json_object\" } } \n    });\n\n    // FIX: Using double curly braces {{ }} to escape the example JSON so LangChain doesn't crash\n    const prompt = PromptTemplate.fromTemplate(\n      `Generate a 10x10 Crossword Puzzle based on the provided text.\n       \n       Rules:\n       1. The grid must be 10x10.\n       2. Use standard crossword rules (words intersect).\n       3. Return a JSON object with:\n          - \"grid\": A 2D array (10 rows of 10 characters). Use '' (empty string) for black squares, single uppercase letters for filled.\n          - \"clues\": An object with \"across\" and \"down\" arrays. Each item: {{ \"number\": 1, \"clue\": \"...\" }}.\n          - \"numbers\": A 2D array (10x10) matching the grid. Put the clue number (1, 2...) in the start cell. 0 if none.\n       \n       Text content: {text}`\n    );\n\n    const chain = prompt.pipe(model);\n    const response = await chain.invoke({ text: note.content.slice(0, 30000) });\n    \n    const content = typeof response.content === 'string' ? response.content : JSON.stringify(response.content);\n    const data = JSON.parse(content);\n    \n    await db.crossword.create({\n      data: {\n        courseId: id,\n        puzzle: data\n      }\n    });\n\n    revalidatePath(`/notes/${id}`);\n  } catch (error) {\n    console.error(\"Crossword Gen Error:\", error);\n  }\n}\n\nexport async function saveQuizResult(courseId: string, score: number, total: number) {\n  try {\n    await db.quizResult.create({\n      data: { courseId, score, total },\n    });\n    revalidatePath(`/notes/${courseId}`);\n  } catch (error) {\n    console.error(\"Save Error:\", error);\n  }\n}\n\nexport async function saveExamResult(courseId: string, score: number, total: number) {\n  try {\n    await db.examResult.create({\n      data: { courseId, score, total },\n    });\n    revalidatePath(`/notes/${courseId}`);\n  } catch (error) {\n    console.error(\"Exam Save Error:\", error);\n  }\n}"],"names":[],"mappings":";;;;;;;IA8PsB,iBAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA"}},
    {"offset": {"line": 108, "column": 0}, "map": {"version":3,"sources":["file:///Users/emilyperez/Study%20App/my-study-app/src/app/actions.ts"],"sourcesContent":["'use server'\n\nimport { db } from \"../lib/db\";\nimport { revalidatePath } from \"next/cache\";\nimport { ChatOpenAI } from \"@langchain/openai\";\nimport { PromptTemplate } from \"@langchain/core/prompts\";\n\n// --- 1. BROWSER MOCKS (Prevents Crashes) ---\n// @ts-ignore\nif (!global.DOMMatrix) { global.DOMMatrix = class DOMMatrix { constructor() {} }; }\n// @ts-ignore\nif (!global.ImageData) { global.ImageData = class ImageData { constructor() {} }; }\n// @ts-ignore\nif (!global.Path2D) { global.Path2D = class Path2D { constructor() {} }; }\n\n// --- 2. SMART IMPORT ---\nlet pdfParse = require(\"pdf-parse\");\nif (typeof pdfParse !== 'function' && pdfParse.default) {\n    pdfParse = pdfParse.default;\n}\n\n// -----------------------------------------------------------\n\nexport async function uploadPdf(formData: FormData) {\n  try {\n    const file = formData.get(\"file\") as File;\n    if (!file) throw new Error(\"No file found\");\n\n    const arrayBuffer = await file.arrayBuffer();\n    const buffer = Buffer.from(arrayBuffer);\n\n    let finalContent = \"No text found.\";\n    \n    try {\n        const data = await pdfParse(buffer);\n        if (data && data.text && data.text.trim().length > 0) {\n            finalContent = data.text;\n        } else {\n            finalContent = \"⚠️ This PDF appears to be empty or scanned (image-only). Text could not be extracted.\";\n        }\n    } catch (parseError) {\n        console.error(\"PDF Parse Error:\", parseError);\n        finalContent = \"⚠️ Error parsing PDF. File might be corrupted or encrypted.\";\n    }\n\n    await db.course.create({\n      data: {\n        title: file.name,\n        content: finalContent,\n      }\n    });\n\n    revalidatePath(\"/\");\n  } catch (error) {\n    console.error(\"Upload Error:\", error);\n  }\n}\n\nexport async function generateStudyGuide(id: string) {\n  try {\n    const note = await db.course.findUnique({ where: { id: id } });\n    if (!note || !note.content) throw new Error(\"Note not found\");\n\n    const model = new ChatOpenAI({ \n      modelName: \"gpt-4o-mini\", \n      openAIApiKey: process.env.OPENAI_API_KEY \n    });\n\n    const prompt = PromptTemplate.fromTemplate(\n      `You are a strict academic tutor. Create a structured study guide.\n       Rules: HTML format only, use <h1>, <h2>, <ul>, <strong>. No Markdown.\n       Text: {text}`\n    );\n\n    const chain = prompt.pipe(model);\n    const response = await chain.invoke({ text: note.content.slice(0, 25000) });\n\n    await db.course.update({\n      where: { id: id },\n      data: { summary: response.content as string }\n    });\n\n    revalidatePath(`/notes/${id}`);\n  } catch (error) {\n    console.error(\"AI Study Guide Error:\", error);\n  }\n}\n\nexport async function generateQuiz(id: string) {\n  try {\n    const note = await db.course.findUnique({ where: { id: id } });\n    if (!note || !note.content) throw new Error(\"Note not found\");\n\n    const model = new ChatOpenAI({\n      modelName: \"gpt-4o-mini\",\n      openAIApiKey: process.env.OPENAI_API_KEY,\n      temperature: 0.1, \n      modelKwargs: { response_format: { type: \"json_object\" } } \n    });\n\n    const prompt = PromptTemplate.fromTemplate(\n      `Generate 5 difficult multiple-choice questions based on the provided text.\n       Return JSON object: {{ \"questions\": [ {{ \"question\": \"...\", \"options\": [\"...\"], \"answer\": \"...\" }} ] }}\n       Text: {text}`\n    );\n\n    const chain = prompt.pipe(model);\n    const response = await chain.invoke({ text: note.content.slice(0, 25000) });\n    \n    const content = typeof response.content === 'string' ? response.content : JSON.stringify(response.content);\n    const data = JSON.parse(content);\n    \n    await db.question.createMany({\n      data: data.questions.map((q: any) => ({\n        courseId: id,\n        question: q.question,\n        options: q.options,\n        answer: q.answer\n      }))\n    });\n\n    revalidatePath(`/notes/${id}`);\n  } catch (error) {\n    console.error(\"AI Quiz Error:\", error);\n  }\n}\n\nexport async function generateFlashcards(id: string) {\n  try {\n    const note = await db.course.findUnique({ where: { id: id } });\n    if (!note || !note.content) throw new Error(\"Note not found\");\n\n    const model = new ChatOpenAI({\n      modelName: \"gpt-4o-mini\",\n      openAIApiKey: process.env.OPENAI_API_KEY,\n      temperature: 0.1, \n      modelKwargs: { response_format: { type: \"json_object\" } } \n    });\n\n    const prompt = PromptTemplate.fromTemplate(\n      `Generate 15 study flashcards based on the provided text.\n       Focus on key definitions, formulas, and concepts.\n       Return JSON object: {{ \"flashcards\": [ {{ \"front\": \"Term\", \"back\": \"Definition\" }} ] }}\n       Text: {text}`\n    );\n\n    const chain = prompt.pipe(model);\n    const response = await chain.invoke({ text: note.content.slice(0, 25000) });\n    \n    const content = typeof response.content === 'string' ? response.content : JSON.stringify(response.content);\n    const data = JSON.parse(content);\n    \n    await db.flashcard.createMany({\n      data: data.flashcards.map((f: any) => ({\n        courseId: id,\n        front: f.front,\n        back: f.back\n      }))\n    });\n\n    revalidatePath(`/notes/${id}`);\n  } catch (error) {\n    console.error(\"Flashcard Gen Error:\", error);\n  }\n}\n\nexport async function generatePracticeExam(id: string) {\n  try {\n    const note = await db.course.findUnique({ where: { id: id } });\n    if (!note || !note.content) throw new Error(\"Note not found\");\n\n    const model = new ChatOpenAI({\n      modelName: \"gpt-4o-mini\",\n      openAIApiKey: process.env.OPENAI_API_KEY,\n      temperature: 0.1, \n      modelKwargs: { response_format: { type: \"json_object\" } } \n    });\n\n    const prompt = PromptTemplate.fromTemplate(\n      `Generate a Practice Midterm Exam with 20 difficult multiple-choice questions based on the text.\n       Include an \"explanation\" field explaining the correct answer.\n       Return JSON object: \n       {{ \"questions\": [ {{ \"question\": \"...\", \"options\": [\"...\"], \"answer\": \"...\", \"explanation\": \"...\" }} ] }}\n       Text: {text}`\n    );\n\n    const chain = prompt.pipe(model);\n    const response = await chain.invoke({ text: note.content.slice(0, 30000) });\n    \n    const content = typeof response.content === 'string' ? response.content : JSON.stringify(response.content);\n    const data = JSON.parse(content);\n    \n    await db.examQuestion.createMany({\n      data: data.questions.map((q: any) => ({\n        courseId: id,\n        question: q.question,\n        options: q.options,\n        answer: q.answer,\n        explanation: q.explanation\n      }))\n    });\n\n    revalidatePath(`/notes/${id}`);\n  } catch (error) {\n    console.error(\"Exam Gen Error:\", error);\n  }\n}\n\nexport async function generateCrossword(id: string) {\n  try {\n    const note = await db.course.findUnique({ where: { id: id } });\n    if (!note || !note.content) throw new Error(\"Note not found\");\n\n    const model = new ChatOpenAI({\n      modelName: \"gpt-4o\", // Stronger model for puzzles\n      openAIApiKey: process.env.OPENAI_API_KEY,\n      temperature: 0.1, \n      modelKwargs: { response_format: { type: \"json_object\" } } \n    });\n\n    // FIX: Using double curly braces {{ }} to escape the example JSON so LangChain doesn't crash\n    const prompt = PromptTemplate.fromTemplate(\n      `Generate a 10x10 Crossword Puzzle based on the provided text.\n       \n       Rules:\n       1. The grid must be 10x10.\n       2. Use standard crossword rules (words intersect).\n       3. Return a JSON object with:\n          - \"grid\": A 2D array (10 rows of 10 characters). Use '' (empty string) for black squares, single uppercase letters for filled.\n          - \"clues\": An object with \"across\" and \"down\" arrays. Each item: {{ \"number\": 1, \"clue\": \"...\" }}.\n          - \"numbers\": A 2D array (10x10) matching the grid. Put the clue number (1, 2...) in the start cell. 0 if none.\n       \n       Text content: {text}`\n    );\n\n    const chain = prompt.pipe(model);\n    const response = await chain.invoke({ text: note.content.slice(0, 30000) });\n    \n    const content = typeof response.content === 'string' ? response.content : JSON.stringify(response.content);\n    const data = JSON.parse(content);\n    \n    await db.crossword.create({\n      data: {\n        courseId: id,\n        puzzle: data\n      }\n    });\n\n    revalidatePath(`/notes/${id}`);\n  } catch (error) {\n    console.error(\"Crossword Gen Error:\", error);\n  }\n}\n\nexport async function saveQuizResult(courseId: string, score: number, total: number) {\n  try {\n    await db.quizResult.create({\n      data: { courseId, score, total },\n    });\n    revalidatePath(`/notes/${courseId}`);\n  } catch (error) {\n    console.error(\"Save Error:\", error);\n  }\n}\n\nexport async function saveExamResult(courseId: string, score: number, total: number) {\n  try {\n    await db.examResult.create({\n      data: { courseId, score, total },\n    });\n    revalidatePath(`/notes/${courseId}`);\n  } catch (error) {\n    console.error(\"Exam Save Error:\", error);\n  }\n}"],"names":[],"mappings":";;;;;;;IAyQsB,iBAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA"}},
    {"offset": {"line": 151, "column": 0}, "map": {"version":3,"sources":["file:///Users/emilyperez/Study%20App/my-study-app/src/components/CourseCard.tsx"],"sourcesContent":["\"use client\";\n\nimport { useState, useRef, useEffect } from \"react\";\nimport Link from \"next/link\";\nimport { deleteCourse, renameCourse } from \"../app/actions\";\n\ntype Course = {\n  id: string;\n  title: string;\n  createdAt: Date;\n  content: string;\n};\n\nexport default function CourseCard({ course }: { course: Course }) {\n  const [isMenuOpen, setIsMenuOpen] = useState(false);\n  const [isEditing, setIsEditing] = useState(false);\n  const [newTitle, setNewTitle] = useState(course.title);\n  const [isDeleting, setIsDeleting] = useState(false);\n  \n  const menuRef = useRef<HTMLDivElement>(null);\n\n  useEffect(() => {\n    function handleClickOutside(event: MouseEvent) {\n      if (menuRef.current && !menuRef.current.contains(event.target as Node)) {\n        setIsMenuOpen(false);\n      }\n    }\n    document.addEventListener(\"mousedown\", handleClickOutside);\n    return () => document.removeEventListener(\"mousedown\", handleClickOutside);\n  }, []);\n\n  const handleRename = async (e: React.FormEvent) => {\n    e.preventDefault(); \n    e.stopPropagation(); \n    \n    if (!newTitle.trim()) return;\n\n    await renameCourse(course.id, newTitle);\n    setIsEditing(false);\n    setIsMenuOpen(false);\n  };\n\n  const handleDelete = async (e: React.MouseEvent) => {\n    e.preventDefault();\n    e.stopPropagation();\n    \n    if (confirm(\"Are you sure you want to delete this study set?\")) {\n      setIsDeleting(true);\n      await deleteCourse(course.id);\n    }\n  };\n\n  if (isDeleting) return null;\n\n  return (\n    <div className=\"relative group bg-white p-6 rounded-xl shadow-sm border border-gray-200 hover:shadow-md hover:border-blue-500 transition\">\n      \n      {/* MENU BUTTON */}\n      <div className=\"absolute top-4 right-4 z-20\" ref={menuRef}>\n        <button \n          onClick={(e) => { e.preventDefault(); e.stopPropagation(); setIsMenuOpen(!isMenuOpen); }}\n          className=\"p-2 rounded-full hover:bg-gray-100 text-gray-400 hover:text-gray-700 transition\"\n        >\n          <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"20\" height=\"20\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" strokeWidth=\"2\" strokeLinecap=\"round\" strokeLinejoin=\"round\">\n            <circle cx=\"12\" cy=\"12\" r=\"1\" />\n            <circle cx=\"19\" cy=\"12\" r=\"1\" />\n            <circle cx=\"5\" cy=\"12\" r=\"1\" />\n          </svg>\n        </button>\n\n        {isMenuOpen && (\n          <div className=\"absolute right-0 mt-1 w-32 bg-white border border-gray-200 rounded-lg shadow-xl overflow-hidden z-30 animate-in fade-in zoom-in-95 duration-100\">\n            <button \n              onClick={(e) => { \n                e.preventDefault(); \n                e.stopPropagation(); \n                setIsEditing(true); \n                setIsMenuOpen(false); \n              }}\n              className=\"w-full text-left px-4 py-2.5 text-sm text-gray-700 hover:bg-gray-50 transition flex items-center gap-2\"\n            >\n              <span>✏️</span> Rename\n            </button>\n            <button \n              onClick={handleDelete}\n              className=\"w-full text-left px-4 py-2.5 text-sm text-red-600 hover:bg-red-50 transition flex items-center gap-2\"\n            >\n              <span>🗑️</span> Delete\n            </button>\n          </div>\n        )}\n      </div>\n\n      {isEditing ? (\n        // RENAME MODE\n        <form onSubmit={handleRename} className=\"relative z-10\" onClick={(e) => e.stopPropagation()}>\n          <input \n            type=\"text\" \n            value={newTitle}\n            onChange={(e) => setNewTitle(e.target.value)}\n            className=\"w-full border-2 border-blue-500 p-2 rounded-lg font-bold text-lg mb-3 focus:outline-none shadow-sm\"\n            autoFocus\n          />\n          <div className=\"flex gap-2\">\n            <button type=\"submit\" className=\"text-xs font-medium bg-blue-600 text-white px-3 py-1.5 rounded-md hover:bg-blue-700 transition\">\n              Save\n            </button>\n            <button type=\"button\" onClick={() => setIsEditing(false)} className=\"text-xs font-medium bg-gray-100 text-gray-600 px-3 py-1.5 rounded-md hover:bg-gray-200 transition\">\n              Cancel\n            </button>\n          </div>\n        </form>\n      ) : (\n        // NORMAL MODE\n        <Link href={`/notes/${course.id}`} className=\"block h-full pr-8\">\n          <div className=\"flex justify-between items-start mb-2\">\n            <h3 className=\"font-bold text-lg text-blue-600 truncate w-full\">{course.title}</h3>\n          </div>\n          <div className=\"flex justify-between items-center mb-4\">\n            <span className=\"text-xs font-medium bg-blue-50 text-blue-600 px-2 py-1 rounded\">PDF</span>\n            \n            {/* --- FIX: Added suppressHydrationWarning --- */}\n            <span className=\"text-xs text-gray-400\" suppressHydrationWarning={true}>\n              {course.createdAt.toLocaleDateString()}\n            </span>\n            \n          </div>\n          <p className=\"text-sm text-gray-500 line-clamp-3\">\n            {course.content || \"No text extracted\"}\n          </p>\n        </Link>\n      )}\n    </div>\n  );\n}"],"names":[],"mappings":";;;;;AAEA;AACA;AACA;AAJA;;;;;AAae,SAAS,WAAW,EAAE,MAAM,EAAsB;IAC/D,MAAM,CAAC,YAAY,cAAc,GAAG,IAAA,iNAAQ,EAAC;IAC7C,MAAM,CAAC,WAAW,aAAa,GAAG,IAAA,iNAAQ,EAAC;IAC3C,MAAM,CAAC,UAAU,YAAY,GAAG,IAAA,iNAAQ,EAAC,OAAO,KAAK;IACrD,MAAM,CAAC,YAAY,cAAc,GAAG,IAAA,iNAAQ,EAAC;IAE7C,MAAM,UAAU,IAAA,+MAAM,EAAiB;IAEvC,IAAA,kNAAS,EAAC;QACR,SAAS,mBAAmB,KAAiB;YAC3C,IAAI,QAAQ,OAAO,IAAI,CAAC,QAAQ,OAAO,CAAC,QAAQ,CAAC,MAAM,MAAM,GAAW;gBACtE,cAAc;YAChB;QACF;QACA,SAAS,gBAAgB,CAAC,aAAa;QACvC,OAAO,IAAM,SAAS,mBAAmB,CAAC,aAAa;IACzD,GAAG,EAAE;IAEL,MAAM,eAAe,OAAO;QAC1B,EAAE,cAAc;QAChB,EAAE,eAAe;QAEjB,IAAI,CAAC,SAAS,IAAI,IAAI;QAEtB,MAAM,IAAA,qIAAY,EAAC,OAAO,EAAE,EAAE;QAC9B,aAAa;QACb,cAAc;IAChB;IAEA,MAAM,eAAe,OAAO;QAC1B,EAAE,cAAc;QAChB,EAAE,eAAe;QAEjB,IAAI,QAAQ,oDAAoD;YAC9D,cAAc;YACd,MAAM,IAAA,qIAAY,EAAC,OAAO,EAAE;QAC9B;IACF;IAEA,IAAI,YAAY,OAAO;IAEvB,qBACE,8OAAC;QAAI,WAAU;;0BAGb,8OAAC;gBAAI,WAAU;gBAA8B,KAAK;;kCAChD,8OAAC;wBACC,SAAS,CAAC;4BAAQ,EAAE,cAAc;4BAAI,EAAE,eAAe;4BAAI,cAAc,CAAC;wBAAa;wBACvF,WAAU;kCAEV,cAAA,8OAAC;4BAAI,OAAM;4BAA6B,OAAM;4BAAK,QAAO;4BAAK,SAAQ;4BAAY,MAAK;4BAAO,QAAO;4BAAe,aAAY;4BAAI,eAAc;4BAAQ,gBAAe;;8CACxK,8OAAC;oCAAO,IAAG;oCAAK,IAAG;oCAAK,GAAE;;;;;;8CAC1B,8OAAC;oCAAO,IAAG;oCAAK,IAAG;oCAAK,GAAE;;;;;;8CAC1B,8OAAC;oCAAO,IAAG;oCAAI,IAAG;oCAAK,GAAE;;;;;;;;;;;;;;;;;oBAI5B,4BACC,8OAAC;wBAAI,WAAU;;0CACb,8OAAC;gCACC,SAAS,CAAC;oCACR,EAAE,cAAc;oCAChB,EAAE,eAAe;oCACjB,aAAa;oCACb,cAAc;gCAChB;gCACA,WAAU;;kDAEV,8OAAC;kDAAK;;;;;;oCAAS;;;;;;;0CAEjB,8OAAC;gCACC,SAAS;gCACT,WAAU;;kDAEV,8OAAC;kDAAK;;;;;;oCAAU;;;;;;;;;;;;;;;;;;;YAMvB,YACC,cAAc;0BACd,8OAAC;gBAAK,UAAU;gBAAc,WAAU;gBAAgB,SAAS,CAAC,IAAM,EAAE,eAAe;;kCACvF,8OAAC;wBACC,MAAK;wBACL,OAAO;wBACP,UAAU,CAAC,IAAM,YAAY,EAAE,MAAM,CAAC,KAAK;wBAC3C,WAAU;wBACV,SAAS;;;;;;kCAEX,8OAAC;wBAAI,WAAU;;0CACb,8OAAC;gCAAO,MAAK;gCAAS,WAAU;0CAAiG;;;;;;0CAGjI,8OAAC;gCAAO,MAAK;gCAAS,SAAS,IAAM,aAAa;gCAAQ,WAAU;0CAAoG;;;;;;;;;;;;;;;;;uBAM5K,cAAc;0BACd,8OAAC,uKAAI;gBAAC,MAAM,CAAC,OAAO,EAAE,OAAO,EAAE,EAAE;gBAAE,WAAU;;kCAC3C,8OAAC;wBAAI,WAAU;kCACb,cAAA,8OAAC;4BAAG,WAAU;sCAAmD,OAAO,KAAK;;;;;;;;;;;kCAE/E,8OAAC;wBAAI,WAAU;;0CACb,8OAAC;gCAAK,WAAU;0CAAiE;;;;;;0CAGjF,8OAAC;gCAAK,WAAU;gCAAwB,0BAA0B;0CAC/D,OAAO,SAAS,CAAC,kBAAkB;;;;;;;;;;;;kCAIxC,8OAAC;wBAAE,WAAU;kCACV,OAAO,OAAO,IAAI;;;;;;;;;;;;;;;;;;AAM/B"}}]
}